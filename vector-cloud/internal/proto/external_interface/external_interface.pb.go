// Code generated by protoc-gen-go. DO NOT EDIT.
// source: external_interface.proto

package Anki_Vector_external_interface

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// <p>The valid versions of the protocol.</p>
// <p>Protocol versions are updated when messages change significantly:
// new ones are added and removed, fields deprecated, etc.</p>
// <p>The goal is to support as many old versions as possible, only
// bumping the minimum when there is no way to handle a prior version.</p>
type ProtocolVersion int32

const (
	ProtocolVersion_PROTOCOL_VERSION_UNKNOWN ProtocolVersion = 0
	ProtocolVersion_PROTOCOL_VERSION_MINIMUM ProtocolVersion = 0
	ProtocolVersion_PROTOCOL_VERSION_CURRENT ProtocolVersion = 5
)

var ProtocolVersion_name = map[int32]string{
	0: "PROTOCOL_VERSION_UNKNOWN",
	// Duplicate value: 0: "PROTOCOL_VERSION_MINIMUM",
	5: "PROTOCOL_VERSION_CURRENT",
}
var ProtocolVersion_value = map[string]int32{
	"PROTOCOL_VERSION_UNKNOWN": 0,
	"PROTOCOL_VERSION_MINIMUM": 0,
	"PROTOCOL_VERSION_CURRENT": 5,
}

func (x ProtocolVersion) String() string {
	return proto.EnumName(ProtocolVersion_name, int32(x))
}
func (ProtocolVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_external_interface_d7251474257069d6, []int{0}
}

func init() {
	proto.RegisterEnum("Anki.Vector.external_interface.ProtocolVersion", ProtocolVersion_name, ProtocolVersion_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ExternalInterface service

type ExternalInterfaceClient interface {
	// Checks the supported protocol version by passing in the client version and
	// minimum host version and receiving a response to see whether the versions are supported.
	ProtocolVersion(ctx context.Context, in *ProtocolVersionRequest, opts ...grpc.CallOption) (*ProtocolVersionResponse, error)
	// SDK-only message to pass version info for device OS, Python version, etc.
	SDKInitialization(ctx context.Context, in *SDKInitializationRequest, opts ...grpc.CallOption) (*SDKInitializationResponse, error)
	// Sets the speed and acceleration for Vector's wheel motors.
	DriveWheels(ctx context.Context, in *DriveWheelsRequest, opts ...grpc.CallOption) (*DriveWheelsResponse, error)
	// Requests that Vector play an animation trigger.
	PlayAnimationTrigger(ctx context.Context, in *PlayAnimationTriggerRequest, opts ...grpc.CallOption) (*PlayAnimationResponse, error)
	// Requests that Vector play an animation.
	PlayAnimation(ctx context.Context, in *PlayAnimationRequest, opts ...grpc.CallOption) (*PlayAnimationResponse, error)
	// Constructs and returns a list of animations.
	ListAnimations(ctx context.Context, in *ListAnimationsRequest, opts ...grpc.CallOption) (*ListAnimationsResponse, error)
	// Constructs and returns a list of animation triggers.
	ListAnimationTriggers(ctx context.Context, in *ListAnimationTriggersRequest, opts ...grpc.CallOption) (*ListAnimationTriggersResponse, error)
	// Moves Vector's head.
	MoveHead(ctx context.Context, in *MoveHeadRequest, opts ...grpc.CallOption) (*MoveHeadResponse, error)
	// Moves Vector's lift.
	MoveLift(ctx context.Context, in *MoveLiftRequest, opts ...grpc.CallOption) (*MoveLiftResponse, error)
	// Stop all motor commands requested: MoveHead, MoveLift and DriveWheels.
	StopAllMotors(ctx context.Context, in *StopAllMotorsRequest, opts ...grpc.CallOption) (*StopAllMotorsResponse, error)
	// Sets screen (Vector's face) to a solid color.
	DisplayFaceImageRGB(ctx context.Context, in *DisplayFaceImageRGBRequest, opts ...grpc.CallOption) (*DisplayFaceImageRGBResponse, error)
	// Streaming events endpoint
	EventStream(ctx context.Context, in *EventRequest, opts ...grpc.CallOption) (ExternalInterface_EventStreamClient, error)
	// Play audio using Vector's speaker
	ExternalAudioStreamPlayback(ctx context.Context, opts ...grpc.CallOption) (ExternalInterface_ExternalAudioStreamPlaybackClient, error)
	// Integrate with and acquire control of Vector's AI system.
	BehaviorControl(ctx context.Context, opts ...grpc.CallOption) (ExternalInterface_BehaviorControlClient, error)
	CancelFaceEnrollment(ctx context.Context, in *CancelFaceEnrollmentRequest, opts ...grpc.CallOption) (*CancelFaceEnrollmentResponse, error)
	// Get a list of names and their IDs.
	RequestEnrolledNames(ctx context.Context, in *RequestEnrolledNamesRequest, opts ...grpc.CallOption) (*RequestEnrolledNamesResponse, error)
	// Update the name enrolled for a given face.
	UpdateEnrolledFaceByID(ctx context.Context, in *UpdateEnrolledFaceByIDRequest, opts ...grpc.CallOption) (*UpdateEnrolledFaceByIDResponse, error)
	// Erase the enrollment (name) record for the face with this ID.
	EraseEnrolledFaceByID(ctx context.Context, in *EraseEnrolledFaceByIDRequest, opts ...grpc.CallOption) (*EraseEnrolledFaceByIDResponse, error)
	// Erase the enrollment (name) records for all faces.
	EraseAllEnrolledFaces(ctx context.Context, in *EraseAllEnrolledFacesRequest, opts ...grpc.CallOption) (*EraseAllEnrolledFacesResponse, error)
	SetFaceToEnroll(ctx context.Context, in *SetFaceToEnrollRequest, opts ...grpc.CallOption) (*SetFaceToEnrollResponse, error)
	// Enroll a face. Must be used with SetFaceToEnroll
	EnrollFace(ctx context.Context, in *EnrollFaceRequest, opts ...grpc.CallOption) (*EnrollFaceResponse, error)
	EnableMarkerDetection(ctx context.Context, in *EnableMarkerDetectionRequest, opts ...grpc.CallOption) (*EnableMarkerDetectionResponse, error)
	EnableFaceDetection(ctx context.Context, in *EnableFaceDetectionRequest, opts ...grpc.CallOption) (*EnableFaceDetectionResponse, error)
	EnableMotionDetection(ctx context.Context, in *EnableMotionDetectionRequest, opts ...grpc.CallOption) (*EnableMotionDetectionResponse, error)
	EnableMirrorMode(ctx context.Context, in *EnableMirrorModeRequest, opts ...grpc.CallOption) (*EnableMirrorModeResponse, error)
	EnableImageStreaming(ctx context.Context, in *EnableImageStreamingRequest, opts ...grpc.CallOption) (*EnableImageStreamingResponse, error)
	IsImageStreamingEnabled(ctx context.Context, in *IsImageStreamingEnabledRequest, opts ...grpc.CallOption) (*IsImageStreamingEnabledResponse, error)
	// Cancel action by id
	CancelActionByIdTag(ctx context.Context, in *CancelActionByIdTagRequest, opts ...grpc.CallOption) (*CancelActionByIdTagResponse, error)
	// Cancel running SDK Behavior
	CancelBehavior(ctx context.Context, in *CancelBehaviorRequest, opts ...grpc.CallOption) (*CancelBehaviorResponse, error)
	// Tells Vector to drive to the specified pose and orientation.
	GoToPose(ctx context.Context, in *GoToPoseRequest, opts ...grpc.CallOption) (*GoToPoseResponse, error)
	// Tells Vector to dock with a light cube with a given approach angle and distance.
	DockWithCube(ctx context.Context, in *DockWithCubeRequest, opts ...grpc.CallOption) (*DockWithCubeResponse, error)
	// Drive Vector off the charger.
	DriveOffCharger(ctx context.Context, in *DriveOffChargerRequest, opts ...grpc.CallOption) (*DriveOffChargerResponse, error)
	// Drive Vector onto the charger.
	DriveOnCharger(ctx context.Context, in *DriveOnChargerRequest, opts ...grpc.CallOption) (*DriveOnChargerResponse, error)
	// Make Vector look for faces by turning and angling his head
	FindFaces(ctx context.Context, in *FindFacesRequest, opts ...grpc.CallOption) (*FindFacesResponse, error)
	// Make Vector look around in place by turning and moving his head
	LookAroundInPlace(ctx context.Context, in *LookAroundInPlaceRequest, opts ...grpc.CallOption) (*LookAroundInPlaceResponse, error)
	// Make Vector roll his block, regardless of relative position and orientation
	RollBlock(ctx context.Context, in *RollBlockRequest, opts ...grpc.CallOption) (*RollBlockResponse, error)
	// Get the photos info.
	PhotosInfo(ctx context.Context, in *PhotosInfoRequest, opts ...grpc.CallOption) (*PhotosInfoResponse, error)
	// Get a photo by ID.
	Photo(ctx context.Context, in *PhotoRequest, opts ...grpc.CallOption) (*PhotoResponse, error)
	// Get a thumbnail by ID.
	Thumbnail(ctx context.Context, in *ThumbnailRequest, opts ...grpc.CallOption) (*ThumbnailResponse, error)
	// Delete a photo by ID.
	DeletePhoto(ctx context.Context, in *DeletePhotoRequest, opts ...grpc.CallOption) (*DeletePhotoResponse, error)
	// Tells Vector to drive in a straight line.
	DriveStraight(ctx context.Context, in *DriveStraightRequest, opts ...grpc.CallOption) (*DriveStraightResponse, error)
	// Turn the robot around its current position.
	TurnInPlace(ctx context.Context, in *TurnInPlaceRequest, opts ...grpc.CallOption) (*TurnInPlaceResponse, error)
	// Tell Vector's head to move to a given angle.
	SetHeadAngle(ctx context.Context, in *SetHeadAngleRequest, opts ...grpc.CallOption) (*SetHeadAngleResponse, error)
	// Tell Vector's lift to move to a given height.
	SetLiftHeight(ctx context.Context, in *SetLiftHeightRequest, opts ...grpc.CallOption) (*SetLiftHeightResponse, error)
	// Tell Vector to turn towards this face.
	TurnTowardsFace(ctx context.Context, in *TurnTowardsFaceRequest, opts ...grpc.CallOption) (*TurnTowardsFaceResponse, error)
	// Tell Vector to drive to the specified object.
	GoToObject(ctx context.Context, in *GoToObjectRequest, opts ...grpc.CallOption) (*GoToObjectResponse, error)
	// Tell Vector to roll his cube.
	RollObject(ctx context.Context, in *RollObjectRequest, opts ...grpc.CallOption) (*RollObjectResponse, error)
	// Tell Vector to "pop a wheelie" using his cube.
	PopAWheelie(ctx context.Context, in *PopAWheelieRequest, opts ...grpc.CallOption) (*PopAWheelieResponse, error)
	// Instruct the robot to pick up the supplied object.
	PickupObject(ctx context.Context, in *PickupObjectRequest, opts ...grpc.CallOption) (*PickupObjectResponse, error)
	// Ask Vector to place the object he is carrying on the ground at the current location.
	PlaceObjectOnGroundHere(ctx context.Context, in *PlaceObjectOnGroundHereRequest, opts ...grpc.CallOption) (*PlaceObjectOnGroundHereResponse, error)
	// Set the Robot's master volume
	SetMasterVolume(ctx context.Context, in *MasterVolumeRequest, opts ...grpc.CallOption) (*MasterVolumeResponse, error)
	UserAuthentication(ctx context.Context, in *UserAuthenticationRequest, opts ...grpc.CallOption) (*UserAuthenticationResponse, error)
	// Check the current state of the battery.
	BatteryState(ctx context.Context, in *BatteryStateRequest, opts ...grpc.CallOption) (*BatteryStateResponse, error)
	// Get the versioning information for Vector.
	VersionState(ctx context.Context, in *VersionStateRequest, opts ...grpc.CallOption) (*VersionStateResponse, error)
	// Make Vector speak text.
	SayText(ctx context.Context, in *SayTextRequest, opts ...grpc.CallOption) (*SayTextResponse, error)
	// Attempt to connect to a cube. If a cube is currently connected,
	// this will do nothing.
	ConnectCube(ctx context.Context, in *ConnectCubeRequest, opts ...grpc.CallOption) (*ConnectCubeResponse, error)
	// Requests a disconnection from the currently connected cube.
	DisconnectCube(ctx context.Context, in *DisconnectCubeRequest, opts ...grpc.CallOption) (*DisconnectCubeResponse, error)
	CubesAvailable(ctx context.Context, in *CubesAvailableRequest, opts ...grpc.CallOption) (*CubesAvailableResponse, error)
	// Signal a connected cube to flash its lights using the default cube
	// flash animation.
	FlashCubeLights(ctx context.Context, in *FlashCubeLightsRequest, opts ...grpc.CallOption) (*FlashCubeLightsResponse, error)
	// Forget the robot's preferred cube. This will cause the robot to
	// connect to the cube with the highest RSSI (signal strength) next
	// time a connection is requested. Saves this preference to disk.
	// The next cube that the robot connects to will become its
	// preferred cube.
	ForgetPreferredCube(ctx context.Context, in *ForgetPreferredCubeRequest, opts ...grpc.CallOption) (*ForgetPreferredCubeResponse, error)
	// Set the robot's preferred cube and save it to disk. The robot
	// will always attempt to connect to this cube if it is available.
	// This is only used in simulation for now.
	SetPreferredCube(ctx context.Context, in *SetPreferredCubeRequest, opts ...grpc.CallOption) (*SetPreferredCubeResponse, error)
	// Causes the robot to forget about custom objects it currently knows about.
	DeleteCustomObjects(ctx context.Context, in *DeleteCustomObjectsRequest, opts ...grpc.CallOption) (*DeleteCustomObjectsResponse, error)
	// Creates a permanent custom object instance in the robot's world, with no connection to the vision system.
	CreateFixedCustomObject(ctx context.Context, in *CreateFixedCustomObjectRequest, opts ...grpc.CallOption) (*CreateFixedCustomObjectResponse, error)
	// Creates a custom object with distinct custom marker(s).
	DefineCustomObject(ctx context.Context, in *DefineCustomObjectRequest, opts ...grpc.CallOption) (*DefineCustomObjectResponse, error)
	// Set each of the lights on the currently connected cube based on two
	// rgb values each and timing data for how to transition between them.
	SetCubeLights(ctx context.Context, in *SetCubeLightsRequest, opts ...grpc.CallOption) (*SetCubeLightsResponse, error)
	// Request an audio feed from the robot.
	AudioFeed(ctx context.Context, in *AudioFeedRequest, opts ...grpc.CallOption) (ExternalInterface_AudioFeedClient, error)
	// Request a camera feed from the robot.
	CameraFeed(ctx context.Context, in *CameraFeedRequest, opts ...grpc.CallOption) (ExternalInterface_CameraFeedClient, error)
	// Request a single image to be captured and sent from the robot.
	CaptureSingleImage(ctx context.Context, in *CaptureSingleImageRequest, opts ...grpc.CallOption) (*CaptureSingleImageResponse, error)
	// Get Vector's camera configuration.
	GetCameraConfig(ctx context.Context, in *CameraConfigRequest, opts ...grpc.CallOption) (*CameraConfigResponse, error)
	// Set Vector's eye color.
	SetEyeColor(ctx context.Context, in *SetEyeColorRequest, opts ...grpc.CallOption) (*SetEyeColorResponse, error)
	// Stream navigation map data.
	NavMapFeed(ctx context.Context, in *NavMapFeedRequest, opts ...grpc.CallOption) (ExternalInterface_NavMapFeedClient, error)
	// Set Vector's camera settings
	SetCameraSettings(ctx context.Context, in *SetCameraSettingsRequest, opts ...grpc.CallOption) (*SetCameraSettingsResponse, error)
	AppIntent(ctx context.Context, in *AppIntentRequest, opts ...grpc.CallOption) (*AppIntentResponse, error)
	GetOnboardingState(ctx context.Context, in *OnboardingStateRequest, opts ...grpc.CallOption) (*OnboardingStateResponse, error)
	SendOnboardingInput(ctx context.Context, in *OnboardingInputRequest, opts ...grpc.CallOption) (*OnboardingInputResponse, error)
	GetLatestAttentionTransfer(ctx context.Context, in *LatestAttentionTransferRequest, opts ...grpc.CallOption) (*LatestAttentionTransferResponse, error)
	PullJdocs(ctx context.Context, in *PullJdocsRequest, opts ...grpc.CallOption) (*PullJdocsResponse, error)
	UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*UpdateSettingsResponse, error)
	UpdateAccountSettings(ctx context.Context, in *UpdateAccountSettingsRequest, opts ...grpc.CallOption) (*UpdateAccountSettingsResponse, error)
	UpdateUserEntitlements(ctx context.Context, in *UpdateUserEntitlementsRequest, opts ...grpc.CallOption) (*UpdateUserEntitlementsResponse, error)
	// StartUpdateEngine cycles the update-engine service (to start a new check for an update) and sets up a stream of
	// UpdateStatusResponse Events.
	StartUpdateEngine(ctx context.Context, in *CheckUpdateStatusRequest, opts ...grpc.CallOption) (*CheckUpdateStatusResponse, error)
	// CheckUpdateStatus tells if the robot is ready to reboot and update.
	CheckUpdateStatus(ctx context.Context, in *CheckUpdateStatusRequest, opts ...grpc.CallOption) (*CheckUpdateStatusResponse, error)
	UpdateAndRestart(ctx context.Context, in *UpdateAndRestartRequest, opts ...grpc.CallOption) (*UpdateAndRestartResponse, error)
	UploadDebugLogs(ctx context.Context, in *UploadDebugLogsRequest, opts ...grpc.CallOption) (*UploadDebugLogsResponse, error)
	CheckCloudConnection(ctx context.Context, in *CheckCloudRequest, opts ...grpc.CallOption) (*CheckCloudResponse, error)
	GetFeatureFlag(ctx context.Context, in *FeatureFlagRequest, opts ...grpc.CallOption) (*FeatureFlagResponse, error)
	GetFeatureFlagList(ctx context.Context, in *FeatureFlagListRequest, opts ...grpc.CallOption) (*FeatureFlagListResponse, error)
	GetAlexaAuthState(ctx context.Context, in *AlexaAuthStateRequest, opts ...grpc.CallOption) (*AlexaAuthStateResponse, error)
	AlexaOptIn(ctx context.Context, in *AlexaOptInRequest, opts ...grpc.CallOption) (*AlexaOptInResponse, error)
	// Acquire control of Vector's AI system.
	AssumeBehaviorControl(ctx context.Context, in *BehaviorControlRequest, opts ...grpc.CallOption) (ExternalInterface_AssumeBehaviorControlClient, error)
}

type externalInterfaceClient struct {
	cc *grpc.ClientConn
}

func NewExternalInterfaceClient(cc *grpc.ClientConn) ExternalInterfaceClient {
	return &externalInterfaceClient{cc}
}

func (c *externalInterfaceClient) ProtocolVersion(ctx context.Context, in *ProtocolVersionRequest, opts ...grpc.CallOption) (*ProtocolVersionResponse, error) {
	out := new(ProtocolVersionResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/ProtocolVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) SDKInitialization(ctx context.Context, in *SDKInitializationRequest, opts ...grpc.CallOption) (*SDKInitializationResponse, error) {
	out := new(SDKInitializationResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SDKInitialization", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) DriveWheels(ctx context.Context, in *DriveWheelsRequest, opts ...grpc.CallOption) (*DriveWheelsResponse, error) {
	out := new(DriveWheelsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/DriveWheels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) PlayAnimationTrigger(ctx context.Context, in *PlayAnimationTriggerRequest, opts ...grpc.CallOption) (*PlayAnimationResponse, error) {
	out := new(PlayAnimationResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/PlayAnimationTrigger", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) PlayAnimation(ctx context.Context, in *PlayAnimationRequest, opts ...grpc.CallOption) (*PlayAnimationResponse, error) {
	out := new(PlayAnimationResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/PlayAnimation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) ListAnimations(ctx context.Context, in *ListAnimationsRequest, opts ...grpc.CallOption) (*ListAnimationsResponse, error) {
	out := new(ListAnimationsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/ListAnimations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) ListAnimationTriggers(ctx context.Context, in *ListAnimationTriggersRequest, opts ...grpc.CallOption) (*ListAnimationTriggersResponse, error) {
	out := new(ListAnimationTriggersResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/ListAnimationTriggers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) MoveHead(ctx context.Context, in *MoveHeadRequest, opts ...grpc.CallOption) (*MoveHeadResponse, error) {
	out := new(MoveHeadResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/MoveHead", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) MoveLift(ctx context.Context, in *MoveLiftRequest, opts ...grpc.CallOption) (*MoveLiftResponse, error) {
	out := new(MoveLiftResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/MoveLift", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) StopAllMotors(ctx context.Context, in *StopAllMotorsRequest, opts ...grpc.CallOption) (*StopAllMotorsResponse, error) {
	out := new(StopAllMotorsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/StopAllMotors", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) DisplayFaceImageRGB(ctx context.Context, in *DisplayFaceImageRGBRequest, opts ...grpc.CallOption) (*DisplayFaceImageRGBResponse, error) {
	out := new(DisplayFaceImageRGBResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/DisplayFaceImageRGB", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) EventStream(ctx context.Context, in *EventRequest, opts ...grpc.CallOption) (ExternalInterface_EventStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ExternalInterface_serviceDesc.Streams[0], c.cc, "/Anki.Vector.external_interface.ExternalInterface/EventStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalInterfaceEventStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExternalInterface_EventStreamClient interface {
	Recv() (*EventResponse, error)
	grpc.ClientStream
}

type externalInterfaceEventStreamClient struct {
	grpc.ClientStream
}

func (x *externalInterfaceEventStreamClient) Recv() (*EventResponse, error) {
	m := new(EventResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *externalInterfaceClient) ExternalAudioStreamPlayback(ctx context.Context, opts ...grpc.CallOption) (ExternalInterface_ExternalAudioStreamPlaybackClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ExternalInterface_serviceDesc.Streams[1], c.cc, "/Anki.Vector.external_interface.ExternalInterface/ExternalAudioStreamPlayback", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalInterfaceExternalAudioStreamPlaybackClient{stream}
	return x, nil
}

type ExternalInterface_ExternalAudioStreamPlaybackClient interface {
	Send(*ExternalAudioStreamRequest) error
	Recv() (*ExternalAudioStreamResponse, error)
	grpc.ClientStream
}

type externalInterfaceExternalAudioStreamPlaybackClient struct {
	grpc.ClientStream
}

func (x *externalInterfaceExternalAudioStreamPlaybackClient) Send(m *ExternalAudioStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *externalInterfaceExternalAudioStreamPlaybackClient) Recv() (*ExternalAudioStreamResponse, error) {
	m := new(ExternalAudioStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *externalInterfaceClient) BehaviorControl(ctx context.Context, opts ...grpc.CallOption) (ExternalInterface_BehaviorControlClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ExternalInterface_serviceDesc.Streams[2], c.cc, "/Anki.Vector.external_interface.ExternalInterface/BehaviorControl", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalInterfaceBehaviorControlClient{stream}
	return x, nil
}

type ExternalInterface_BehaviorControlClient interface {
	Send(*BehaviorControlRequest) error
	Recv() (*BehaviorControlResponse, error)
	grpc.ClientStream
}

type externalInterfaceBehaviorControlClient struct {
	grpc.ClientStream
}

func (x *externalInterfaceBehaviorControlClient) Send(m *BehaviorControlRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *externalInterfaceBehaviorControlClient) Recv() (*BehaviorControlResponse, error) {
	m := new(BehaviorControlResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *externalInterfaceClient) CancelFaceEnrollment(ctx context.Context, in *CancelFaceEnrollmentRequest, opts ...grpc.CallOption) (*CancelFaceEnrollmentResponse, error) {
	out := new(CancelFaceEnrollmentResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/CancelFaceEnrollment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) RequestEnrolledNames(ctx context.Context, in *RequestEnrolledNamesRequest, opts ...grpc.CallOption) (*RequestEnrolledNamesResponse, error) {
	out := new(RequestEnrolledNamesResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/RequestEnrolledNames", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) UpdateEnrolledFaceByID(ctx context.Context, in *UpdateEnrolledFaceByIDRequest, opts ...grpc.CallOption) (*UpdateEnrolledFaceByIDResponse, error) {
	out := new(UpdateEnrolledFaceByIDResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/UpdateEnrolledFaceByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) EraseEnrolledFaceByID(ctx context.Context, in *EraseEnrolledFaceByIDRequest, opts ...grpc.CallOption) (*EraseEnrolledFaceByIDResponse, error) {
	out := new(EraseEnrolledFaceByIDResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/EraseEnrolledFaceByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) EraseAllEnrolledFaces(ctx context.Context, in *EraseAllEnrolledFacesRequest, opts ...grpc.CallOption) (*EraseAllEnrolledFacesResponse, error) {
	out := new(EraseAllEnrolledFacesResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/EraseAllEnrolledFaces", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) SetFaceToEnroll(ctx context.Context, in *SetFaceToEnrollRequest, opts ...grpc.CallOption) (*SetFaceToEnrollResponse, error) {
	out := new(SetFaceToEnrollResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SetFaceToEnroll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) EnrollFace(ctx context.Context, in *EnrollFaceRequest, opts ...grpc.CallOption) (*EnrollFaceResponse, error) {
	out := new(EnrollFaceResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/EnrollFace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) EnableMarkerDetection(ctx context.Context, in *EnableMarkerDetectionRequest, opts ...grpc.CallOption) (*EnableMarkerDetectionResponse, error) {
	out := new(EnableMarkerDetectionResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/EnableMarkerDetection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) EnableFaceDetection(ctx context.Context, in *EnableFaceDetectionRequest, opts ...grpc.CallOption) (*EnableFaceDetectionResponse, error) {
	out := new(EnableFaceDetectionResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/EnableFaceDetection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) EnableMotionDetection(ctx context.Context, in *EnableMotionDetectionRequest, opts ...grpc.CallOption) (*EnableMotionDetectionResponse, error) {
	out := new(EnableMotionDetectionResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/EnableMotionDetection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) EnableMirrorMode(ctx context.Context, in *EnableMirrorModeRequest, opts ...grpc.CallOption) (*EnableMirrorModeResponse, error) {
	out := new(EnableMirrorModeResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/EnableMirrorMode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) EnableImageStreaming(ctx context.Context, in *EnableImageStreamingRequest, opts ...grpc.CallOption) (*EnableImageStreamingResponse, error) {
	out := new(EnableImageStreamingResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/EnableImageStreaming", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) IsImageStreamingEnabled(ctx context.Context, in *IsImageStreamingEnabledRequest, opts ...grpc.CallOption) (*IsImageStreamingEnabledResponse, error) {
	out := new(IsImageStreamingEnabledResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/IsImageStreamingEnabled", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) CancelActionByIdTag(ctx context.Context, in *CancelActionByIdTagRequest, opts ...grpc.CallOption) (*CancelActionByIdTagResponse, error) {
	out := new(CancelActionByIdTagResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/CancelActionByIdTag", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) CancelBehavior(ctx context.Context, in *CancelBehaviorRequest, opts ...grpc.CallOption) (*CancelBehaviorResponse, error) {
	out := new(CancelBehaviorResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/CancelBehavior", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) GoToPose(ctx context.Context, in *GoToPoseRequest, opts ...grpc.CallOption) (*GoToPoseResponse, error) {
	out := new(GoToPoseResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/GoToPose", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) DockWithCube(ctx context.Context, in *DockWithCubeRequest, opts ...grpc.CallOption) (*DockWithCubeResponse, error) {
	out := new(DockWithCubeResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/DockWithCube", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) DriveOffCharger(ctx context.Context, in *DriveOffChargerRequest, opts ...grpc.CallOption) (*DriveOffChargerResponse, error) {
	out := new(DriveOffChargerResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/DriveOffCharger", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) DriveOnCharger(ctx context.Context, in *DriveOnChargerRequest, opts ...grpc.CallOption) (*DriveOnChargerResponse, error) {
	out := new(DriveOnChargerResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/DriveOnCharger", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) FindFaces(ctx context.Context, in *FindFacesRequest, opts ...grpc.CallOption) (*FindFacesResponse, error) {
	out := new(FindFacesResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/FindFaces", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) LookAroundInPlace(ctx context.Context, in *LookAroundInPlaceRequest, opts ...grpc.CallOption) (*LookAroundInPlaceResponse, error) {
	out := new(LookAroundInPlaceResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/LookAroundInPlace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) RollBlock(ctx context.Context, in *RollBlockRequest, opts ...grpc.CallOption) (*RollBlockResponse, error) {
	out := new(RollBlockResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/RollBlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) PhotosInfo(ctx context.Context, in *PhotosInfoRequest, opts ...grpc.CallOption) (*PhotosInfoResponse, error) {
	out := new(PhotosInfoResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/PhotosInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) Photo(ctx context.Context, in *PhotoRequest, opts ...grpc.CallOption) (*PhotoResponse, error) {
	out := new(PhotoResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/Photo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) Thumbnail(ctx context.Context, in *ThumbnailRequest, opts ...grpc.CallOption) (*ThumbnailResponse, error) {
	out := new(ThumbnailResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/Thumbnail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) DeletePhoto(ctx context.Context, in *DeletePhotoRequest, opts ...grpc.CallOption) (*DeletePhotoResponse, error) {
	out := new(DeletePhotoResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/DeletePhoto", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) DriveStraight(ctx context.Context, in *DriveStraightRequest, opts ...grpc.CallOption) (*DriveStraightResponse, error) {
	out := new(DriveStraightResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/DriveStraight", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) TurnInPlace(ctx context.Context, in *TurnInPlaceRequest, opts ...grpc.CallOption) (*TurnInPlaceResponse, error) {
	out := new(TurnInPlaceResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/TurnInPlace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) SetHeadAngle(ctx context.Context, in *SetHeadAngleRequest, opts ...grpc.CallOption) (*SetHeadAngleResponse, error) {
	out := new(SetHeadAngleResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SetHeadAngle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) SetLiftHeight(ctx context.Context, in *SetLiftHeightRequest, opts ...grpc.CallOption) (*SetLiftHeightResponse, error) {
	out := new(SetLiftHeightResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SetLiftHeight", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) TurnTowardsFace(ctx context.Context, in *TurnTowardsFaceRequest, opts ...grpc.CallOption) (*TurnTowardsFaceResponse, error) {
	out := new(TurnTowardsFaceResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/TurnTowardsFace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) GoToObject(ctx context.Context, in *GoToObjectRequest, opts ...grpc.CallOption) (*GoToObjectResponse, error) {
	out := new(GoToObjectResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/GoToObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) RollObject(ctx context.Context, in *RollObjectRequest, opts ...grpc.CallOption) (*RollObjectResponse, error) {
	out := new(RollObjectResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/RollObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) PopAWheelie(ctx context.Context, in *PopAWheelieRequest, opts ...grpc.CallOption) (*PopAWheelieResponse, error) {
	out := new(PopAWheelieResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/PopAWheelie", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) PickupObject(ctx context.Context, in *PickupObjectRequest, opts ...grpc.CallOption) (*PickupObjectResponse, error) {
	out := new(PickupObjectResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/PickupObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) PlaceObjectOnGroundHere(ctx context.Context, in *PlaceObjectOnGroundHereRequest, opts ...grpc.CallOption) (*PlaceObjectOnGroundHereResponse, error) {
	out := new(PlaceObjectOnGroundHereResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/PlaceObjectOnGroundHere", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) SetMasterVolume(ctx context.Context, in *MasterVolumeRequest, opts ...grpc.CallOption) (*MasterVolumeResponse, error) {
	out := new(MasterVolumeResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SetMasterVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) UserAuthentication(ctx context.Context, in *UserAuthenticationRequest, opts ...grpc.CallOption) (*UserAuthenticationResponse, error) {
	out := new(UserAuthenticationResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/UserAuthentication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) BatteryState(ctx context.Context, in *BatteryStateRequest, opts ...grpc.CallOption) (*BatteryStateResponse, error) {
	out := new(BatteryStateResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/BatteryState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) VersionState(ctx context.Context, in *VersionStateRequest, opts ...grpc.CallOption) (*VersionStateResponse, error) {
	out := new(VersionStateResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/VersionState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) SayText(ctx context.Context, in *SayTextRequest, opts ...grpc.CallOption) (*SayTextResponse, error) {
	out := new(SayTextResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SayText", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) ConnectCube(ctx context.Context, in *ConnectCubeRequest, opts ...grpc.CallOption) (*ConnectCubeResponse, error) {
	out := new(ConnectCubeResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/ConnectCube", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) DisconnectCube(ctx context.Context, in *DisconnectCubeRequest, opts ...grpc.CallOption) (*DisconnectCubeResponse, error) {
	out := new(DisconnectCubeResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/DisconnectCube", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) CubesAvailable(ctx context.Context, in *CubesAvailableRequest, opts ...grpc.CallOption) (*CubesAvailableResponse, error) {
	out := new(CubesAvailableResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/CubesAvailable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) FlashCubeLights(ctx context.Context, in *FlashCubeLightsRequest, opts ...grpc.CallOption) (*FlashCubeLightsResponse, error) {
	out := new(FlashCubeLightsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/FlashCubeLights", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) ForgetPreferredCube(ctx context.Context, in *ForgetPreferredCubeRequest, opts ...grpc.CallOption) (*ForgetPreferredCubeResponse, error) {
	out := new(ForgetPreferredCubeResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/ForgetPreferredCube", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) SetPreferredCube(ctx context.Context, in *SetPreferredCubeRequest, opts ...grpc.CallOption) (*SetPreferredCubeResponse, error) {
	out := new(SetPreferredCubeResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SetPreferredCube", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) DeleteCustomObjects(ctx context.Context, in *DeleteCustomObjectsRequest, opts ...grpc.CallOption) (*DeleteCustomObjectsResponse, error) {
	out := new(DeleteCustomObjectsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/DeleteCustomObjects", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) CreateFixedCustomObject(ctx context.Context, in *CreateFixedCustomObjectRequest, opts ...grpc.CallOption) (*CreateFixedCustomObjectResponse, error) {
	out := new(CreateFixedCustomObjectResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/CreateFixedCustomObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) DefineCustomObject(ctx context.Context, in *DefineCustomObjectRequest, opts ...grpc.CallOption) (*DefineCustomObjectResponse, error) {
	out := new(DefineCustomObjectResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/DefineCustomObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) SetCubeLights(ctx context.Context, in *SetCubeLightsRequest, opts ...grpc.CallOption) (*SetCubeLightsResponse, error) {
	out := new(SetCubeLightsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SetCubeLights", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) AudioFeed(ctx context.Context, in *AudioFeedRequest, opts ...grpc.CallOption) (ExternalInterface_AudioFeedClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ExternalInterface_serviceDesc.Streams[3], c.cc, "/Anki.Vector.external_interface.ExternalInterface/AudioFeed", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalInterfaceAudioFeedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExternalInterface_AudioFeedClient interface {
	Recv() (*AudioFeedResponse, error)
	grpc.ClientStream
}

type externalInterfaceAudioFeedClient struct {
	grpc.ClientStream
}

func (x *externalInterfaceAudioFeedClient) Recv() (*AudioFeedResponse, error) {
	m := new(AudioFeedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *externalInterfaceClient) CameraFeed(ctx context.Context, in *CameraFeedRequest, opts ...grpc.CallOption) (ExternalInterface_CameraFeedClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ExternalInterface_serviceDesc.Streams[4], c.cc, "/Anki.Vector.external_interface.ExternalInterface/CameraFeed", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalInterfaceCameraFeedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExternalInterface_CameraFeedClient interface {
	Recv() (*CameraFeedResponse, error)
	grpc.ClientStream
}

type externalInterfaceCameraFeedClient struct {
	grpc.ClientStream
}

func (x *externalInterfaceCameraFeedClient) Recv() (*CameraFeedResponse, error) {
	m := new(CameraFeedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *externalInterfaceClient) CaptureSingleImage(ctx context.Context, in *CaptureSingleImageRequest, opts ...grpc.CallOption) (*CaptureSingleImageResponse, error) {
	out := new(CaptureSingleImageResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/CaptureSingleImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) GetCameraConfig(ctx context.Context, in *CameraConfigRequest, opts ...grpc.CallOption) (*CameraConfigResponse, error) {
	out := new(CameraConfigResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/GetCameraConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) SetEyeColor(ctx context.Context, in *SetEyeColorRequest, opts ...grpc.CallOption) (*SetEyeColorResponse, error) {
	out := new(SetEyeColorResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SetEyeColor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) NavMapFeed(ctx context.Context, in *NavMapFeedRequest, opts ...grpc.CallOption) (ExternalInterface_NavMapFeedClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ExternalInterface_serviceDesc.Streams[5], c.cc, "/Anki.Vector.external_interface.ExternalInterface/NavMapFeed", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalInterfaceNavMapFeedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExternalInterface_NavMapFeedClient interface {
	Recv() (*NavMapFeedResponse, error)
	grpc.ClientStream
}

type externalInterfaceNavMapFeedClient struct {
	grpc.ClientStream
}

func (x *externalInterfaceNavMapFeedClient) Recv() (*NavMapFeedResponse, error) {
	m := new(NavMapFeedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *externalInterfaceClient) SetCameraSettings(ctx context.Context, in *SetCameraSettingsRequest, opts ...grpc.CallOption) (*SetCameraSettingsResponse, error) {
	out := new(SetCameraSettingsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SetCameraSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) AppIntent(ctx context.Context, in *AppIntentRequest, opts ...grpc.CallOption) (*AppIntentResponse, error) {
	out := new(AppIntentResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/AppIntent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) GetOnboardingState(ctx context.Context, in *OnboardingStateRequest, opts ...grpc.CallOption) (*OnboardingStateResponse, error) {
	out := new(OnboardingStateResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/GetOnboardingState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) SendOnboardingInput(ctx context.Context, in *OnboardingInputRequest, opts ...grpc.CallOption) (*OnboardingInputResponse, error) {
	out := new(OnboardingInputResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/SendOnboardingInput", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) GetLatestAttentionTransfer(ctx context.Context, in *LatestAttentionTransferRequest, opts ...grpc.CallOption) (*LatestAttentionTransferResponse, error) {
	out := new(LatestAttentionTransferResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/GetLatestAttentionTransfer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) PullJdocs(ctx context.Context, in *PullJdocsRequest, opts ...grpc.CallOption) (*PullJdocsResponse, error) {
	out := new(PullJdocsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/PullJdocs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*UpdateSettingsResponse, error) {
	out := new(UpdateSettingsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/UpdateSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) UpdateAccountSettings(ctx context.Context, in *UpdateAccountSettingsRequest, opts ...grpc.CallOption) (*UpdateAccountSettingsResponse, error) {
	out := new(UpdateAccountSettingsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/UpdateAccountSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) UpdateUserEntitlements(ctx context.Context, in *UpdateUserEntitlementsRequest, opts ...grpc.CallOption) (*UpdateUserEntitlementsResponse, error) {
	out := new(UpdateUserEntitlementsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/UpdateUserEntitlements", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) StartUpdateEngine(ctx context.Context, in *CheckUpdateStatusRequest, opts ...grpc.CallOption) (*CheckUpdateStatusResponse, error) {
	out := new(CheckUpdateStatusResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/StartUpdateEngine", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) CheckUpdateStatus(ctx context.Context, in *CheckUpdateStatusRequest, opts ...grpc.CallOption) (*CheckUpdateStatusResponse, error) {
	out := new(CheckUpdateStatusResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/CheckUpdateStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) UpdateAndRestart(ctx context.Context, in *UpdateAndRestartRequest, opts ...grpc.CallOption) (*UpdateAndRestartResponse, error) {
	out := new(UpdateAndRestartResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/UpdateAndRestart", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) UploadDebugLogs(ctx context.Context, in *UploadDebugLogsRequest, opts ...grpc.CallOption) (*UploadDebugLogsResponse, error) {
	out := new(UploadDebugLogsResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/UploadDebugLogs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) CheckCloudConnection(ctx context.Context, in *CheckCloudRequest, opts ...grpc.CallOption) (*CheckCloudResponse, error) {
	out := new(CheckCloudResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/CheckCloudConnection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) GetFeatureFlag(ctx context.Context, in *FeatureFlagRequest, opts ...grpc.CallOption) (*FeatureFlagResponse, error) {
	out := new(FeatureFlagResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/GetFeatureFlag", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) GetFeatureFlagList(ctx context.Context, in *FeatureFlagListRequest, opts ...grpc.CallOption) (*FeatureFlagListResponse, error) {
	out := new(FeatureFlagListResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/GetFeatureFlagList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) GetAlexaAuthState(ctx context.Context, in *AlexaAuthStateRequest, opts ...grpc.CallOption) (*AlexaAuthStateResponse, error) {
	out := new(AlexaAuthStateResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/GetAlexaAuthState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) AlexaOptIn(ctx context.Context, in *AlexaOptInRequest, opts ...grpc.CallOption) (*AlexaOptInResponse, error) {
	out := new(AlexaOptInResponse)
	err := grpc.Invoke(ctx, "/Anki.Vector.external_interface.ExternalInterface/AlexaOptIn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalInterfaceClient) AssumeBehaviorControl(ctx context.Context, in *BehaviorControlRequest, opts ...grpc.CallOption) (ExternalInterface_AssumeBehaviorControlClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ExternalInterface_serviceDesc.Streams[6], c.cc, "/Anki.Vector.external_interface.ExternalInterface/AssumeBehaviorControl", opts...)
	if err != nil {
		return nil, err
	}
	x := &externalInterfaceAssumeBehaviorControlClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExternalInterface_AssumeBehaviorControlClient interface {
	Recv() (*BehaviorControlResponse, error)
	grpc.ClientStream
}

type externalInterfaceAssumeBehaviorControlClient struct {
	grpc.ClientStream
}

func (x *externalInterfaceAssumeBehaviorControlClient) Recv() (*BehaviorControlResponse, error) {
	m := new(BehaviorControlResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ExternalInterface service

type ExternalInterfaceServer interface {
	// Checks the supported protocol version by passing in the client version and
	// minimum host version and receiving a response to see whether the versions are supported.
	ProtocolVersion(context.Context, *ProtocolVersionRequest) (*ProtocolVersionResponse, error)
	// SDK-only message to pass version info for device OS, Python version, etc.
	SDKInitialization(context.Context, *SDKInitializationRequest) (*SDKInitializationResponse, error)
	// Sets the speed and acceleration for Vector's wheel motors.
	DriveWheels(context.Context, *DriveWheelsRequest) (*DriveWheelsResponse, error)
	// Requests that Vector play an animation trigger.
	PlayAnimationTrigger(context.Context, *PlayAnimationTriggerRequest) (*PlayAnimationResponse, error)
	// Requests that Vector play an animation.
	PlayAnimation(context.Context, *PlayAnimationRequest) (*PlayAnimationResponse, error)
	// Constructs and returns a list of animations.
	ListAnimations(context.Context, *ListAnimationsRequest) (*ListAnimationsResponse, error)
	// Constructs and returns a list of animation triggers.
	ListAnimationTriggers(context.Context, *ListAnimationTriggersRequest) (*ListAnimationTriggersResponse, error)
	// Moves Vector's head.
	MoveHead(context.Context, *MoveHeadRequest) (*MoveHeadResponse, error)
	// Moves Vector's lift.
	MoveLift(context.Context, *MoveLiftRequest) (*MoveLiftResponse, error)
	// Stop all motor commands requested: MoveHead, MoveLift and DriveWheels.
	StopAllMotors(context.Context, *StopAllMotorsRequest) (*StopAllMotorsResponse, error)
	// Sets screen (Vector's face) to a solid color.
	DisplayFaceImageRGB(context.Context, *DisplayFaceImageRGBRequest) (*DisplayFaceImageRGBResponse, error)
	// Streaming events endpoint
	EventStream(*EventRequest, ExternalInterface_EventStreamServer) error
	// Play audio using Vector's speaker
	ExternalAudioStreamPlayback(ExternalInterface_ExternalAudioStreamPlaybackServer) error
	// Integrate with and acquire control of Vector's AI system.
	BehaviorControl(ExternalInterface_BehaviorControlServer) error
	CancelFaceEnrollment(context.Context, *CancelFaceEnrollmentRequest) (*CancelFaceEnrollmentResponse, error)
	// Get a list of names and their IDs.
	RequestEnrolledNames(context.Context, *RequestEnrolledNamesRequest) (*RequestEnrolledNamesResponse, error)
	// Update the name enrolled for a given face.
	UpdateEnrolledFaceByID(context.Context, *UpdateEnrolledFaceByIDRequest) (*UpdateEnrolledFaceByIDResponse, error)
	// Erase the enrollment (name) record for the face with this ID.
	EraseEnrolledFaceByID(context.Context, *EraseEnrolledFaceByIDRequest) (*EraseEnrolledFaceByIDResponse, error)
	// Erase the enrollment (name) records for all faces.
	EraseAllEnrolledFaces(context.Context, *EraseAllEnrolledFacesRequest) (*EraseAllEnrolledFacesResponse, error)
	SetFaceToEnroll(context.Context, *SetFaceToEnrollRequest) (*SetFaceToEnrollResponse, error)
	// Enroll a face. Must be used with SetFaceToEnroll
	EnrollFace(context.Context, *EnrollFaceRequest) (*EnrollFaceResponse, error)
	EnableMarkerDetection(context.Context, *EnableMarkerDetectionRequest) (*EnableMarkerDetectionResponse, error)
	EnableFaceDetection(context.Context, *EnableFaceDetectionRequest) (*EnableFaceDetectionResponse, error)
	EnableMotionDetection(context.Context, *EnableMotionDetectionRequest) (*EnableMotionDetectionResponse, error)
	EnableMirrorMode(context.Context, *EnableMirrorModeRequest) (*EnableMirrorModeResponse, error)
	EnableImageStreaming(context.Context, *EnableImageStreamingRequest) (*EnableImageStreamingResponse, error)
	IsImageStreamingEnabled(context.Context, *IsImageStreamingEnabledRequest) (*IsImageStreamingEnabledResponse, error)
	// Cancel action by id
	CancelActionByIdTag(context.Context, *CancelActionByIdTagRequest) (*CancelActionByIdTagResponse, error)
	// Cancel running SDK Behavior
	CancelBehavior(context.Context, *CancelBehaviorRequest) (*CancelBehaviorResponse, error)
	// Tells Vector to drive to the specified pose and orientation.
	GoToPose(context.Context, *GoToPoseRequest) (*GoToPoseResponse, error)
	// Tells Vector to dock with a light cube with a given approach angle and distance.
	DockWithCube(context.Context, *DockWithCubeRequest) (*DockWithCubeResponse, error)
	// Drive Vector off the charger.
	DriveOffCharger(context.Context, *DriveOffChargerRequest) (*DriveOffChargerResponse, error)
	// Drive Vector onto the charger.
	DriveOnCharger(context.Context, *DriveOnChargerRequest) (*DriveOnChargerResponse, error)
	// Make Vector look for faces by turning and angling his head
	FindFaces(context.Context, *FindFacesRequest) (*FindFacesResponse, error)
	// Make Vector look around in place by turning and moving his head
	LookAroundInPlace(context.Context, *LookAroundInPlaceRequest) (*LookAroundInPlaceResponse, error)
	// Make Vector roll his block, regardless of relative position and orientation
	RollBlock(context.Context, *RollBlockRequest) (*RollBlockResponse, error)
	// Get the photos info.
	PhotosInfo(context.Context, *PhotosInfoRequest) (*PhotosInfoResponse, error)
	// Get a photo by ID.
	Photo(context.Context, *PhotoRequest) (*PhotoResponse, error)
	// Get a thumbnail by ID.
	Thumbnail(context.Context, *ThumbnailRequest) (*ThumbnailResponse, error)
	// Delete a photo by ID.
	DeletePhoto(context.Context, *DeletePhotoRequest) (*DeletePhotoResponse, error)
	// Tells Vector to drive in a straight line.
	DriveStraight(context.Context, *DriveStraightRequest) (*DriveStraightResponse, error)
	// Turn the robot around its current position.
	TurnInPlace(context.Context, *TurnInPlaceRequest) (*TurnInPlaceResponse, error)
	// Tell Vector's head to move to a given angle.
	SetHeadAngle(context.Context, *SetHeadAngleRequest) (*SetHeadAngleResponse, error)
	// Tell Vector's lift to move to a given height.
	SetLiftHeight(context.Context, *SetLiftHeightRequest) (*SetLiftHeightResponse, error)
	// Tell Vector to turn towards this face.
	TurnTowardsFace(context.Context, *TurnTowardsFaceRequest) (*TurnTowardsFaceResponse, error)
	// Tell Vector to drive to the specified object.
	GoToObject(context.Context, *GoToObjectRequest) (*GoToObjectResponse, error)
	// Tell Vector to roll his cube.
	RollObject(context.Context, *RollObjectRequest) (*RollObjectResponse, error)
	// Tell Vector to "pop a wheelie" using his cube.
	PopAWheelie(context.Context, *PopAWheelieRequest) (*PopAWheelieResponse, error)
	// Instruct the robot to pick up the supplied object.
	PickupObject(context.Context, *PickupObjectRequest) (*PickupObjectResponse, error)
	// Ask Vector to place the object he is carrying on the ground at the current location.
	PlaceObjectOnGroundHere(context.Context, *PlaceObjectOnGroundHereRequest) (*PlaceObjectOnGroundHereResponse, error)
	// Set the Robot's master volume
	SetMasterVolume(context.Context, *MasterVolumeRequest) (*MasterVolumeResponse, error)
	UserAuthentication(context.Context, *UserAuthenticationRequest) (*UserAuthenticationResponse, error)
	// Check the current state of the battery.
	BatteryState(context.Context, *BatteryStateRequest) (*BatteryStateResponse, error)
	// Get the versioning information for Vector.
	VersionState(context.Context, *VersionStateRequest) (*VersionStateResponse, error)
	// Make Vector speak text.
	SayText(context.Context, *SayTextRequest) (*SayTextResponse, error)
	// Attempt to connect to a cube. If a cube is currently connected,
	// this will do nothing.
	ConnectCube(context.Context, *ConnectCubeRequest) (*ConnectCubeResponse, error)
	// Requests a disconnection from the currently connected cube.
	DisconnectCube(context.Context, *DisconnectCubeRequest) (*DisconnectCubeResponse, error)
	CubesAvailable(context.Context, *CubesAvailableRequest) (*CubesAvailableResponse, error)
	// Signal a connected cube to flash its lights using the default cube
	// flash animation.
	FlashCubeLights(context.Context, *FlashCubeLightsRequest) (*FlashCubeLightsResponse, error)
	// Forget the robot's preferred cube. This will cause the robot to
	// connect to the cube with the highest RSSI (signal strength) next
	// time a connection is requested. Saves this preference to disk.
	// The next cube that the robot connects to will become its
	// preferred cube.
	ForgetPreferredCube(context.Context, *ForgetPreferredCubeRequest) (*ForgetPreferredCubeResponse, error)
	// Set the robot's preferred cube and save it to disk. The robot
	// will always attempt to connect to this cube if it is available.
	// This is only used in simulation for now.
	SetPreferredCube(context.Context, *SetPreferredCubeRequest) (*SetPreferredCubeResponse, error)
	// Causes the robot to forget about custom objects it currently knows about.
	DeleteCustomObjects(context.Context, *DeleteCustomObjectsRequest) (*DeleteCustomObjectsResponse, error)
	// Creates a permanent custom object instance in the robot's world, with no connection to the vision system.
	CreateFixedCustomObject(context.Context, *CreateFixedCustomObjectRequest) (*CreateFixedCustomObjectResponse, error)
	// Creates a custom object with distinct custom marker(s).
	DefineCustomObject(context.Context, *DefineCustomObjectRequest) (*DefineCustomObjectResponse, error)
	// Set each of the lights on the currently connected cube based on two
	// rgb values each and timing data for how to transition between them.
	SetCubeLights(context.Context, *SetCubeLightsRequest) (*SetCubeLightsResponse, error)
	// Request an audio feed from the robot.
	AudioFeed(*AudioFeedRequest, ExternalInterface_AudioFeedServer) error
	// Request a camera feed from the robot.
	CameraFeed(*CameraFeedRequest, ExternalInterface_CameraFeedServer) error
	// Request a single image to be captured and sent from the robot.
	CaptureSingleImage(context.Context, *CaptureSingleImageRequest) (*CaptureSingleImageResponse, error)
	// Get Vector's camera configuration.
	GetCameraConfig(context.Context, *CameraConfigRequest) (*CameraConfigResponse, error)
	// Set Vector's eye color.
	SetEyeColor(context.Context, *SetEyeColorRequest) (*SetEyeColorResponse, error)
	// Stream navigation map data.
	NavMapFeed(*NavMapFeedRequest, ExternalInterface_NavMapFeedServer) error
	// Set Vector's camera settings
	SetCameraSettings(context.Context, *SetCameraSettingsRequest) (*SetCameraSettingsResponse, error)
	AppIntent(context.Context, *AppIntentRequest) (*AppIntentResponse, error)
	GetOnboardingState(context.Context, *OnboardingStateRequest) (*OnboardingStateResponse, error)
	SendOnboardingInput(context.Context, *OnboardingInputRequest) (*OnboardingInputResponse, error)
	GetLatestAttentionTransfer(context.Context, *LatestAttentionTransferRequest) (*LatestAttentionTransferResponse, error)
	PullJdocs(context.Context, *PullJdocsRequest) (*PullJdocsResponse, error)
	UpdateSettings(context.Context, *UpdateSettingsRequest) (*UpdateSettingsResponse, error)
	UpdateAccountSettings(context.Context, *UpdateAccountSettingsRequest) (*UpdateAccountSettingsResponse, error)
	UpdateUserEntitlements(context.Context, *UpdateUserEntitlementsRequest) (*UpdateUserEntitlementsResponse, error)
	// StartUpdateEngine cycles the update-engine service (to start a new check for an update) and sets up a stream of
	// UpdateStatusResponse Events.
	StartUpdateEngine(context.Context, *CheckUpdateStatusRequest) (*CheckUpdateStatusResponse, error)
	// CheckUpdateStatus tells if the robot is ready to reboot and update.
	CheckUpdateStatus(context.Context, *CheckUpdateStatusRequest) (*CheckUpdateStatusResponse, error)
	UpdateAndRestart(context.Context, *UpdateAndRestartRequest) (*UpdateAndRestartResponse, error)
	UploadDebugLogs(context.Context, *UploadDebugLogsRequest) (*UploadDebugLogsResponse, error)
	CheckCloudConnection(context.Context, *CheckCloudRequest) (*CheckCloudResponse, error)
	GetFeatureFlag(context.Context, *FeatureFlagRequest) (*FeatureFlagResponse, error)
	GetFeatureFlagList(context.Context, *FeatureFlagListRequest) (*FeatureFlagListResponse, error)
	GetAlexaAuthState(context.Context, *AlexaAuthStateRequest) (*AlexaAuthStateResponse, error)
	AlexaOptIn(context.Context, *AlexaOptInRequest) (*AlexaOptInResponse, error)
	// Acquire control of Vector's AI system.
	AssumeBehaviorControl(*BehaviorControlRequest, ExternalInterface_AssumeBehaviorControlServer) error
}

func RegisterExternalInterfaceServer(s *grpc.Server, srv ExternalInterfaceServer) {
	s.RegisterService(&_ExternalInterface_serviceDesc, srv)
}

func _ExternalInterface_ProtocolVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtocolVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).ProtocolVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/ProtocolVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).ProtocolVersion(ctx, req.(*ProtocolVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_SDKInitialization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SDKInitializationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SDKInitialization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SDKInitialization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SDKInitialization(ctx, req.(*SDKInitializationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_DriveWheels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DriveWheelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).DriveWheels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/DriveWheels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).DriveWheels(ctx, req.(*DriveWheelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_PlayAnimationTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayAnimationTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).PlayAnimationTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/PlayAnimationTrigger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).PlayAnimationTrigger(ctx, req.(*PlayAnimationTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_PlayAnimation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayAnimationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).PlayAnimation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/PlayAnimation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).PlayAnimation(ctx, req.(*PlayAnimationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_ListAnimations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAnimationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).ListAnimations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/ListAnimations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).ListAnimations(ctx, req.(*ListAnimationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_ListAnimationTriggers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAnimationTriggersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).ListAnimationTriggers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/ListAnimationTriggers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).ListAnimationTriggers(ctx, req.(*ListAnimationTriggersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_MoveHead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveHeadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).MoveHead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/MoveHead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).MoveHead(ctx, req.(*MoveHeadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_MoveLift_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveLiftRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).MoveLift(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/MoveLift",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).MoveLift(ctx, req.(*MoveLiftRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_StopAllMotors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopAllMotorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).StopAllMotors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/StopAllMotors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).StopAllMotors(ctx, req.(*StopAllMotorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_DisplayFaceImageRGB_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisplayFaceImageRGBRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).DisplayFaceImageRGB(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/DisplayFaceImageRGB",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).DisplayFaceImageRGB(ctx, req.(*DisplayFaceImageRGBRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_EventStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExternalInterfaceServer).EventStream(m, &externalInterfaceEventStreamServer{stream})
}

type ExternalInterface_EventStreamServer interface {
	Send(*EventResponse) error
	grpc.ServerStream
}

type externalInterfaceEventStreamServer struct {
	grpc.ServerStream
}

func (x *externalInterfaceEventStreamServer) Send(m *EventResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ExternalInterface_ExternalAudioStreamPlayback_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExternalInterfaceServer).ExternalAudioStreamPlayback(&externalInterfaceExternalAudioStreamPlaybackServer{stream})
}

type ExternalInterface_ExternalAudioStreamPlaybackServer interface {
	Send(*ExternalAudioStreamResponse) error
	Recv() (*ExternalAudioStreamRequest, error)
	grpc.ServerStream
}

type externalInterfaceExternalAudioStreamPlaybackServer struct {
	grpc.ServerStream
}

func (x *externalInterfaceExternalAudioStreamPlaybackServer) Send(m *ExternalAudioStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *externalInterfaceExternalAudioStreamPlaybackServer) Recv() (*ExternalAudioStreamRequest, error) {
	m := new(ExternalAudioStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ExternalInterface_BehaviorControl_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExternalInterfaceServer).BehaviorControl(&externalInterfaceBehaviorControlServer{stream})
}

type ExternalInterface_BehaviorControlServer interface {
	Send(*BehaviorControlResponse) error
	Recv() (*BehaviorControlRequest, error)
	grpc.ServerStream
}

type externalInterfaceBehaviorControlServer struct {
	grpc.ServerStream
}

func (x *externalInterfaceBehaviorControlServer) Send(m *BehaviorControlResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *externalInterfaceBehaviorControlServer) Recv() (*BehaviorControlRequest, error) {
	m := new(BehaviorControlRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ExternalInterface_CancelFaceEnrollment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelFaceEnrollmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).CancelFaceEnrollment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/CancelFaceEnrollment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).CancelFaceEnrollment(ctx, req.(*CancelFaceEnrollmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_RequestEnrolledNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEnrolledNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).RequestEnrolledNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/RequestEnrolledNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).RequestEnrolledNames(ctx, req.(*RequestEnrolledNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_UpdateEnrolledFaceByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEnrolledFaceByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).UpdateEnrolledFaceByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/UpdateEnrolledFaceByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).UpdateEnrolledFaceByID(ctx, req.(*UpdateEnrolledFaceByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_EraseEnrolledFaceByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EraseEnrolledFaceByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).EraseEnrolledFaceByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/EraseEnrolledFaceByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).EraseEnrolledFaceByID(ctx, req.(*EraseEnrolledFaceByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_EraseAllEnrolledFaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EraseAllEnrolledFacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).EraseAllEnrolledFaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/EraseAllEnrolledFaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).EraseAllEnrolledFaces(ctx, req.(*EraseAllEnrolledFacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_SetFaceToEnroll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetFaceToEnrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SetFaceToEnroll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SetFaceToEnroll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SetFaceToEnroll(ctx, req.(*SetFaceToEnrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_EnrollFace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnrollFaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).EnrollFace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/EnrollFace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).EnrollFace(ctx, req.(*EnrollFaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_EnableMarkerDetection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableMarkerDetectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).EnableMarkerDetection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/EnableMarkerDetection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).EnableMarkerDetection(ctx, req.(*EnableMarkerDetectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_EnableFaceDetection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableFaceDetectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).EnableFaceDetection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/EnableFaceDetection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).EnableFaceDetection(ctx, req.(*EnableFaceDetectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_EnableMotionDetection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableMotionDetectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).EnableMotionDetection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/EnableMotionDetection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).EnableMotionDetection(ctx, req.(*EnableMotionDetectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_EnableMirrorMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableMirrorModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).EnableMirrorMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/EnableMirrorMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).EnableMirrorMode(ctx, req.(*EnableMirrorModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_EnableImageStreaming_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableImageStreamingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).EnableImageStreaming(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/EnableImageStreaming",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).EnableImageStreaming(ctx, req.(*EnableImageStreamingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_IsImageStreamingEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsImageStreamingEnabledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).IsImageStreamingEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/IsImageStreamingEnabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).IsImageStreamingEnabled(ctx, req.(*IsImageStreamingEnabledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_CancelActionByIdTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelActionByIdTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).CancelActionByIdTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/CancelActionByIdTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).CancelActionByIdTag(ctx, req.(*CancelActionByIdTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_CancelBehavior_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelBehaviorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).CancelBehavior(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/CancelBehavior",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).CancelBehavior(ctx, req.(*CancelBehaviorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_GoToPose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoToPoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).GoToPose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/GoToPose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).GoToPose(ctx, req.(*GoToPoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_DockWithCube_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DockWithCubeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).DockWithCube(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/DockWithCube",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).DockWithCube(ctx, req.(*DockWithCubeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_DriveOffCharger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DriveOffChargerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).DriveOffCharger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/DriveOffCharger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).DriveOffCharger(ctx, req.(*DriveOffChargerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_DriveOnCharger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DriveOnChargerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).DriveOnCharger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/DriveOnCharger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).DriveOnCharger(ctx, req.(*DriveOnChargerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_FindFaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindFacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).FindFaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/FindFaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).FindFaces(ctx, req.(*FindFacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_LookAroundInPlace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookAroundInPlaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).LookAroundInPlace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/LookAroundInPlace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).LookAroundInPlace(ctx, req.(*LookAroundInPlaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_RollBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).RollBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/RollBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).RollBlock(ctx, req.(*RollBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_PhotosInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhotosInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).PhotosInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/PhotosInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).PhotosInfo(ctx, req.(*PhotosInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_Photo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhotoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).Photo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/Photo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).Photo(ctx, req.(*PhotoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_Thumbnail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ThumbnailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).Thumbnail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/Thumbnail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).Thumbnail(ctx, req.(*ThumbnailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_DeletePhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePhotoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).DeletePhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/DeletePhoto",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).DeletePhoto(ctx, req.(*DeletePhotoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_DriveStraight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DriveStraightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).DriveStraight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/DriveStraight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).DriveStraight(ctx, req.(*DriveStraightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_TurnInPlace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TurnInPlaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).TurnInPlace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/TurnInPlace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).TurnInPlace(ctx, req.(*TurnInPlaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_SetHeadAngle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetHeadAngleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SetHeadAngle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SetHeadAngle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SetHeadAngle(ctx, req.(*SetHeadAngleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_SetLiftHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLiftHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SetLiftHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SetLiftHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SetLiftHeight(ctx, req.(*SetLiftHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_TurnTowardsFace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TurnTowardsFaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).TurnTowardsFace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/TurnTowardsFace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).TurnTowardsFace(ctx, req.(*TurnTowardsFaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_GoToObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoToObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).GoToObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/GoToObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).GoToObject(ctx, req.(*GoToObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_RollObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).RollObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/RollObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).RollObject(ctx, req.(*RollObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_PopAWheelie_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PopAWheelieRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).PopAWheelie(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/PopAWheelie",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).PopAWheelie(ctx, req.(*PopAWheelieRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_PickupObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PickupObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).PickupObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/PickupObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).PickupObject(ctx, req.(*PickupObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_PlaceObjectOnGroundHere_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaceObjectOnGroundHereRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).PlaceObjectOnGroundHere(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/PlaceObjectOnGroundHere",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).PlaceObjectOnGroundHere(ctx, req.(*PlaceObjectOnGroundHereRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_SetMasterVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MasterVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SetMasterVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SetMasterVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SetMasterVolume(ctx, req.(*MasterVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_UserAuthentication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthenticationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).UserAuthentication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/UserAuthentication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).UserAuthentication(ctx, req.(*UserAuthenticationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_BatteryState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatteryStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).BatteryState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/BatteryState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).BatteryState(ctx, req.(*BatteryStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_VersionState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).VersionState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/VersionState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).VersionState(ctx, req.(*VersionStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_SayText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SayTextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SayText(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SayText",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SayText(ctx, req.(*SayTextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_ConnectCube_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectCubeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).ConnectCube(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/ConnectCube",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).ConnectCube(ctx, req.(*ConnectCubeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_DisconnectCube_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectCubeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).DisconnectCube(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/DisconnectCube",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).DisconnectCube(ctx, req.(*DisconnectCubeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_CubesAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CubesAvailableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).CubesAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/CubesAvailable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).CubesAvailable(ctx, req.(*CubesAvailableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_FlashCubeLights_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlashCubeLightsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).FlashCubeLights(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/FlashCubeLights",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).FlashCubeLights(ctx, req.(*FlashCubeLightsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_ForgetPreferredCube_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForgetPreferredCubeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).ForgetPreferredCube(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/ForgetPreferredCube",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).ForgetPreferredCube(ctx, req.(*ForgetPreferredCubeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_SetPreferredCube_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPreferredCubeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SetPreferredCube(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SetPreferredCube",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SetPreferredCube(ctx, req.(*SetPreferredCubeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_DeleteCustomObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCustomObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).DeleteCustomObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/DeleteCustomObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).DeleteCustomObjects(ctx, req.(*DeleteCustomObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_CreateFixedCustomObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFixedCustomObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).CreateFixedCustomObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/CreateFixedCustomObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).CreateFixedCustomObject(ctx, req.(*CreateFixedCustomObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_DefineCustomObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefineCustomObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).DefineCustomObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/DefineCustomObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).DefineCustomObject(ctx, req.(*DefineCustomObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_SetCubeLights_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCubeLightsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SetCubeLights(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SetCubeLights",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SetCubeLights(ctx, req.(*SetCubeLightsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_AudioFeed_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AudioFeedRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExternalInterfaceServer).AudioFeed(m, &externalInterfaceAudioFeedServer{stream})
}

type ExternalInterface_AudioFeedServer interface {
	Send(*AudioFeedResponse) error
	grpc.ServerStream
}

type externalInterfaceAudioFeedServer struct {
	grpc.ServerStream
}

func (x *externalInterfaceAudioFeedServer) Send(m *AudioFeedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ExternalInterface_CameraFeed_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CameraFeedRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExternalInterfaceServer).CameraFeed(m, &externalInterfaceCameraFeedServer{stream})
}

type ExternalInterface_CameraFeedServer interface {
	Send(*CameraFeedResponse) error
	grpc.ServerStream
}

type externalInterfaceCameraFeedServer struct {
	grpc.ServerStream
}

func (x *externalInterfaceCameraFeedServer) Send(m *CameraFeedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ExternalInterface_CaptureSingleImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CaptureSingleImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).CaptureSingleImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/CaptureSingleImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).CaptureSingleImage(ctx, req.(*CaptureSingleImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_GetCameraConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CameraConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).GetCameraConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/GetCameraConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).GetCameraConfig(ctx, req.(*CameraConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_SetEyeColor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetEyeColorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SetEyeColor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SetEyeColor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SetEyeColor(ctx, req.(*SetEyeColorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_NavMapFeed_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NavMapFeedRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExternalInterfaceServer).NavMapFeed(m, &externalInterfaceNavMapFeedServer{stream})
}

type ExternalInterface_NavMapFeedServer interface {
	Send(*NavMapFeedResponse) error
	grpc.ServerStream
}

type externalInterfaceNavMapFeedServer struct {
	grpc.ServerStream
}

func (x *externalInterfaceNavMapFeedServer) Send(m *NavMapFeedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ExternalInterface_SetCameraSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCameraSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SetCameraSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SetCameraSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SetCameraSettings(ctx, req.(*SetCameraSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_AppIntent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppIntentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).AppIntent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/AppIntent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).AppIntent(ctx, req.(*AppIntentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_GetOnboardingState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnboardingStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).GetOnboardingState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/GetOnboardingState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).GetOnboardingState(ctx, req.(*OnboardingStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_SendOnboardingInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnboardingInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).SendOnboardingInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/SendOnboardingInput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).SendOnboardingInput(ctx, req.(*OnboardingInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_GetLatestAttentionTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestAttentionTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).GetLatestAttentionTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/GetLatestAttentionTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).GetLatestAttentionTransfer(ctx, req.(*LatestAttentionTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_PullJdocs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullJdocsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).PullJdocs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/PullJdocs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).PullJdocs(ctx, req.(*PullJdocsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_UpdateSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).UpdateSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/UpdateSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).UpdateSettings(ctx, req.(*UpdateSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_UpdateAccountSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAccountSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).UpdateAccountSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/UpdateAccountSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).UpdateAccountSettings(ctx, req.(*UpdateAccountSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_UpdateUserEntitlements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserEntitlementsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).UpdateUserEntitlements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/UpdateUserEntitlements",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).UpdateUserEntitlements(ctx, req.(*UpdateUserEntitlementsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_StartUpdateEngine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).StartUpdateEngine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/StartUpdateEngine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).StartUpdateEngine(ctx, req.(*CheckUpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_CheckUpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).CheckUpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/CheckUpdateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).CheckUpdateStatus(ctx, req.(*CheckUpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_UpdateAndRestart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAndRestartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).UpdateAndRestart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/UpdateAndRestart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).UpdateAndRestart(ctx, req.(*UpdateAndRestartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_UploadDebugLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadDebugLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).UploadDebugLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/UploadDebugLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).UploadDebugLogs(ctx, req.(*UploadDebugLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_CheckCloudConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckCloudRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).CheckCloudConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/CheckCloudConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).CheckCloudConnection(ctx, req.(*CheckCloudRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_GetFeatureFlag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeatureFlagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).GetFeatureFlag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/GetFeatureFlag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).GetFeatureFlag(ctx, req.(*FeatureFlagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_GetFeatureFlagList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeatureFlagListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).GetFeatureFlagList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/GetFeatureFlagList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).GetFeatureFlagList(ctx, req.(*FeatureFlagListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_GetAlexaAuthState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlexaAuthStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).GetAlexaAuthState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/GetAlexaAuthState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).GetAlexaAuthState(ctx, req.(*AlexaAuthStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_AlexaOptIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlexaOptInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalInterfaceServer).AlexaOptIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Anki.Vector.external_interface.ExternalInterface/AlexaOptIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalInterfaceServer).AlexaOptIn(ctx, req.(*AlexaOptInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalInterface_AssumeBehaviorControl_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BehaviorControlRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExternalInterfaceServer).AssumeBehaviorControl(m, &externalInterfaceAssumeBehaviorControlServer{stream})
}

type ExternalInterface_AssumeBehaviorControlServer interface {
	Send(*BehaviorControlResponse) error
	grpc.ServerStream
}

type externalInterfaceAssumeBehaviorControlServer struct {
	grpc.ServerStream
}

func (x *externalInterfaceAssumeBehaviorControlServer) Send(m *BehaviorControlResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ExternalInterface_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Anki.Vector.external_interface.ExternalInterface",
	HandlerType: (*ExternalInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProtocolVersion",
			Handler:    _ExternalInterface_ProtocolVersion_Handler,
		},
		{
			MethodName: "SDKInitialization",
			Handler:    _ExternalInterface_SDKInitialization_Handler,
		},
		{
			MethodName: "DriveWheels",
			Handler:    _ExternalInterface_DriveWheels_Handler,
		},
		{
			MethodName: "PlayAnimationTrigger",
			Handler:    _ExternalInterface_PlayAnimationTrigger_Handler,
		},
		{
			MethodName: "PlayAnimation",
			Handler:    _ExternalInterface_PlayAnimation_Handler,
		},
		{
			MethodName: "ListAnimations",
			Handler:    _ExternalInterface_ListAnimations_Handler,
		},
		{
			MethodName: "ListAnimationTriggers",
			Handler:    _ExternalInterface_ListAnimationTriggers_Handler,
		},
		{
			MethodName: "MoveHead",
			Handler:    _ExternalInterface_MoveHead_Handler,
		},
		{
			MethodName: "MoveLift",
			Handler:    _ExternalInterface_MoveLift_Handler,
		},
		{
			MethodName: "StopAllMotors",
			Handler:    _ExternalInterface_StopAllMotors_Handler,
		},
		{
			MethodName: "DisplayFaceImageRGB",
			Handler:    _ExternalInterface_DisplayFaceImageRGB_Handler,
		},
		{
			MethodName: "CancelFaceEnrollment",
			Handler:    _ExternalInterface_CancelFaceEnrollment_Handler,
		},
		{
			MethodName: "RequestEnrolledNames",
			Handler:    _ExternalInterface_RequestEnrolledNames_Handler,
		},
		{
			MethodName: "UpdateEnrolledFaceByID",
			Handler:    _ExternalInterface_UpdateEnrolledFaceByID_Handler,
		},
		{
			MethodName: "EraseEnrolledFaceByID",
			Handler:    _ExternalInterface_EraseEnrolledFaceByID_Handler,
		},
		{
			MethodName: "EraseAllEnrolledFaces",
			Handler:    _ExternalInterface_EraseAllEnrolledFaces_Handler,
		},
		{
			MethodName: "SetFaceToEnroll",
			Handler:    _ExternalInterface_SetFaceToEnroll_Handler,
		},
		{
			MethodName: "EnrollFace",
			Handler:    _ExternalInterface_EnrollFace_Handler,
		},
		{
			MethodName: "EnableMarkerDetection",
			Handler:    _ExternalInterface_EnableMarkerDetection_Handler,
		},
		{
			MethodName: "EnableFaceDetection",
			Handler:    _ExternalInterface_EnableFaceDetection_Handler,
		},
		{
			MethodName: "EnableMotionDetection",
			Handler:    _ExternalInterface_EnableMotionDetection_Handler,
		},
		{
			MethodName: "EnableMirrorMode",
			Handler:    _ExternalInterface_EnableMirrorMode_Handler,
		},
		{
			MethodName: "EnableImageStreaming",
			Handler:    _ExternalInterface_EnableImageStreaming_Handler,
		},
		{
			MethodName: "IsImageStreamingEnabled",
			Handler:    _ExternalInterface_IsImageStreamingEnabled_Handler,
		},
		{
			MethodName: "CancelActionByIdTag",
			Handler:    _ExternalInterface_CancelActionByIdTag_Handler,
		},
		{
			MethodName: "CancelBehavior",
			Handler:    _ExternalInterface_CancelBehavior_Handler,
		},
		{
			MethodName: "GoToPose",
			Handler:    _ExternalInterface_GoToPose_Handler,
		},
		{
			MethodName: "DockWithCube",
			Handler:    _ExternalInterface_DockWithCube_Handler,
		},
		{
			MethodName: "DriveOffCharger",
			Handler:    _ExternalInterface_DriveOffCharger_Handler,
		},
		{
			MethodName: "DriveOnCharger",
			Handler:    _ExternalInterface_DriveOnCharger_Handler,
		},
		{
			MethodName: "FindFaces",
			Handler:    _ExternalInterface_FindFaces_Handler,
		},
		{
			MethodName: "LookAroundInPlace",
			Handler:    _ExternalInterface_LookAroundInPlace_Handler,
		},
		{
			MethodName: "RollBlock",
			Handler:    _ExternalInterface_RollBlock_Handler,
		},
		{
			MethodName: "PhotosInfo",
			Handler:    _ExternalInterface_PhotosInfo_Handler,
		},
		{
			MethodName: "Photo",
			Handler:    _ExternalInterface_Photo_Handler,
		},
		{
			MethodName: "Thumbnail",
			Handler:    _ExternalInterface_Thumbnail_Handler,
		},
		{
			MethodName: "DeletePhoto",
			Handler:    _ExternalInterface_DeletePhoto_Handler,
		},
		{
			MethodName: "DriveStraight",
			Handler:    _ExternalInterface_DriveStraight_Handler,
		},
		{
			MethodName: "TurnInPlace",
			Handler:    _ExternalInterface_TurnInPlace_Handler,
		},
		{
			MethodName: "SetHeadAngle",
			Handler:    _ExternalInterface_SetHeadAngle_Handler,
		},
		{
			MethodName: "SetLiftHeight",
			Handler:    _ExternalInterface_SetLiftHeight_Handler,
		},
		{
			MethodName: "TurnTowardsFace",
			Handler:    _ExternalInterface_TurnTowardsFace_Handler,
		},
		{
			MethodName: "GoToObject",
			Handler:    _ExternalInterface_GoToObject_Handler,
		},
		{
			MethodName: "RollObject",
			Handler:    _ExternalInterface_RollObject_Handler,
		},
		{
			MethodName: "PopAWheelie",
			Handler:    _ExternalInterface_PopAWheelie_Handler,
		},
		{
			MethodName: "PickupObject",
			Handler:    _ExternalInterface_PickupObject_Handler,
		},
		{
			MethodName: "PlaceObjectOnGroundHere",
			Handler:    _ExternalInterface_PlaceObjectOnGroundHere_Handler,
		},
		{
			MethodName: "SetMasterVolume",
			Handler:    _ExternalInterface_SetMasterVolume_Handler,
		},
		{
			MethodName: "UserAuthentication",
			Handler:    _ExternalInterface_UserAuthentication_Handler,
		},
		{
			MethodName: "BatteryState",
			Handler:    _ExternalInterface_BatteryState_Handler,
		},
		{
			MethodName: "VersionState",
			Handler:    _ExternalInterface_VersionState_Handler,
		},
		{
			MethodName: "SayText",
			Handler:    _ExternalInterface_SayText_Handler,
		},
		{
			MethodName: "ConnectCube",
			Handler:    _ExternalInterface_ConnectCube_Handler,
		},
		{
			MethodName: "DisconnectCube",
			Handler:    _ExternalInterface_DisconnectCube_Handler,
		},
		{
			MethodName: "CubesAvailable",
			Handler:    _ExternalInterface_CubesAvailable_Handler,
		},
		{
			MethodName: "FlashCubeLights",
			Handler:    _ExternalInterface_FlashCubeLights_Handler,
		},
		{
			MethodName: "ForgetPreferredCube",
			Handler:    _ExternalInterface_ForgetPreferredCube_Handler,
		},
		{
			MethodName: "SetPreferredCube",
			Handler:    _ExternalInterface_SetPreferredCube_Handler,
		},
		{
			MethodName: "DeleteCustomObjects",
			Handler:    _ExternalInterface_DeleteCustomObjects_Handler,
		},
		{
			MethodName: "CreateFixedCustomObject",
			Handler:    _ExternalInterface_CreateFixedCustomObject_Handler,
		},
		{
			MethodName: "DefineCustomObject",
			Handler:    _ExternalInterface_DefineCustomObject_Handler,
		},
		{
			MethodName: "SetCubeLights",
			Handler:    _ExternalInterface_SetCubeLights_Handler,
		},
		{
			MethodName: "CaptureSingleImage",
			Handler:    _ExternalInterface_CaptureSingleImage_Handler,
		},
		{
			MethodName: "GetCameraConfig",
			Handler:    _ExternalInterface_GetCameraConfig_Handler,
		},
		{
			MethodName: "SetEyeColor",
			Handler:    _ExternalInterface_SetEyeColor_Handler,
		},
		{
			MethodName: "SetCameraSettings",
			Handler:    _ExternalInterface_SetCameraSettings_Handler,
		},
		{
			MethodName: "AppIntent",
			Handler:    _ExternalInterface_AppIntent_Handler,
		},
		{
			MethodName: "GetOnboardingState",
			Handler:    _ExternalInterface_GetOnboardingState_Handler,
		},
		{
			MethodName: "SendOnboardingInput",
			Handler:    _ExternalInterface_SendOnboardingInput_Handler,
		},
		{
			MethodName: "GetLatestAttentionTransfer",
			Handler:    _ExternalInterface_GetLatestAttentionTransfer_Handler,
		},
		{
			MethodName: "PullJdocs",
			Handler:    _ExternalInterface_PullJdocs_Handler,
		},
		{
			MethodName: "UpdateSettings",
			Handler:    _ExternalInterface_UpdateSettings_Handler,
		},
		{
			MethodName: "UpdateAccountSettings",
			Handler:    _ExternalInterface_UpdateAccountSettings_Handler,
		},
		{
			MethodName: "UpdateUserEntitlements",
			Handler:    _ExternalInterface_UpdateUserEntitlements_Handler,
		},
		{
			MethodName: "StartUpdateEngine",
			Handler:    _ExternalInterface_StartUpdateEngine_Handler,
		},
		{
			MethodName: "CheckUpdateStatus",
			Handler:    _ExternalInterface_CheckUpdateStatus_Handler,
		},
		{
			MethodName: "UpdateAndRestart",
			Handler:    _ExternalInterface_UpdateAndRestart_Handler,
		},
		{
			MethodName: "UploadDebugLogs",
			Handler:    _ExternalInterface_UploadDebugLogs_Handler,
		},
		{
			MethodName: "CheckCloudConnection",
			Handler:    _ExternalInterface_CheckCloudConnection_Handler,
		},
		{
			MethodName: "GetFeatureFlag",
			Handler:    _ExternalInterface_GetFeatureFlag_Handler,
		},
		{
			MethodName: "GetFeatureFlagList",
			Handler:    _ExternalInterface_GetFeatureFlagList_Handler,
		},
		{
			MethodName: "GetAlexaAuthState",
			Handler:    _ExternalInterface_GetAlexaAuthState_Handler,
		},
		{
			MethodName: "AlexaOptIn",
			Handler:    _ExternalInterface_AlexaOptIn_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "EventStream",
			Handler:       _ExternalInterface_EventStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExternalAudioStreamPlayback",
			Handler:       _ExternalInterface_ExternalAudioStreamPlayback_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "BehaviorControl",
			Handler:       _ExternalInterface_BehaviorControl_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "AudioFeed",
			Handler:       _ExternalInterface_AudioFeed_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CameraFeed",
			Handler:       _ExternalInterface_CameraFeed_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "NavMapFeed",
			Handler:       _ExternalInterface_NavMapFeed_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AssumeBehaviorControl",
			Handler:       _ExternalInterface_AssumeBehaviorControl_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "external_interface.proto",
}

func init() {
	proto.RegisterFile("external_interface.proto", fileDescriptor_external_interface_d7251474257069d6)
}

var fileDescriptor_external_interface_d7251474257069d6 = []byte{
	// 3021 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5b, 0xcb, 0x8f, 0x1c, 0x47,
	0x19, 0x4f, 0x45, 0x0a, 0xc4, 0xe5, 0xc7, 0x7a, 0xdb, 0x76, 0xec, 0xac, 0x1d, 0x27, 0x99, 0x40,
	0x48, 0xa2, 0xe0, 0xb5, 0x93, 0xd8, 0x09, 0x4e, 0x00, 0xcd, 0xce, 0x3e, 0x3c, 0x64, 0x5f, 0xda,
	0xd9, 0xb5, 0x25, 0x2e, 0xad, 0x9a, 0xee, 0x6f, 0x66, 0x3b, 0xdb, 0x53, 0xd5, 0x74, 0x57, 0x6f,
	0x76, 0x83, 0x94, 0x03, 0x70, 0x88, 0x78, 0x88, 0x47, 0x10, 0x70, 0x08, 0x01, 0x29, 0x41, 0x44,
	0x10, 0x04, 0x42, 0x80, 0x38, 0x04, 0x84, 0x90, 0x38, 0x71, 0xe4, 0x5f, 0xe0, 0x0f, 0x41, 0x55,
	0x5d, 0xd5, 0xd3, 0x3d, 0x5d, 0x9b, 0xaa, 0x59, 0x0e, 0x70, 0xf3, 0xb8, 0x7f, 0xbf, 0xaa, 0x5f,
	0x7d, 0xf5, 0x75, 0x7d, 0x8f, 0xae, 0xc5, 0x97, 0xe0, 0x80, 0x43, 0x4a, 0x49, 0xec, 0x47, 0x94,
	0x43, 0x3a, 0x20, 0x01, 0x5c, 0x4b, 0x52, 0xc6, 0x99, 0x77, 0xb5, 0x4d, 0xf7, 0xa2, 0x6b, 0x77,
	0x21, 0xe0, 0x2c, 0xbd, 0xd6, 0x44, 0xcd, 0x5d, 0x19, 0x32, 0x36, 0x8c, 0x61, 0x9e, 0x24, 0xd1,
	0x3c, 0xa1, 0x94, 0x71, 0xc2, 0x23, 0x46, 0xb3, 0x82, 0x3d, 0x77, 0x92, 0xc4, 0x70, 0x40, 0xd4,
	0x8f, 0x33, 0x7d, 0xd8, 0x25, 0xfb, 0x11, 0x4b, 0xd5, 0x6f, 0x1c, 0xe4, 0x7d, 0xd0, 0xcf, 0x46,
	0x90, 0x65, 0x64, 0x08, 0x9a, 0x78, 0x9a, 0x92, 0x7d, 0x7f, 0x44, 0x12, 0xfd, 0x38, 0x03, 0xce,
	0x23, 0x3a, 0xd4, 0x8f, 0x4f, 0x65, 0xbb, 0x24, 0x85, 0xb0, 0xf8, 0xf5, 0x0c, 0xc3, 0x33, 0x9b,
	0xe2, 0x1f, 0x01, 0x8b, 0xef, 0x42, 0x9a, 0x45, 0x8c, 0x7a, 0x57, 0xf0, 0xa5, 0xcd, 0xad, 0x8d,
	0xed, 0x8d, 0xce, 0xc6, 0xaa, 0x7f, 0x77, 0x69, 0xab, 0xd7, 0xdd, 0x58, 0xf7, 0x77, 0xd6, 0x5f,
	0x5d, 0xdf, 0xb8, 0xb7, 0x7e, 0xf6, 0x3e, 0xe3, 0xd3, 0xb5, 0xee, 0x7a, 0x77, 0x6d, 0x67, 0xed,
	0x88, 0xa7, 0x9d, 0x9d, 0xad, 0xad, 0xa5, 0xf5, 0xed, 0xb3, 0x0f, 0xcc, 0xdd, 0x7f, 0x16, 0x3d,
	0xf7, 0x6e, 0x82, 0x67, 0x97, 0x94, 0x2d, 0xba, 0xda, 0x14, 0xde, 0x7b, 0xa8, 0xa9, 0xe3, 0xd6,
	0xb5, 0x8f, 0xb7, 0xdf, 0xb5, 0x09, 0xc2, 0x16, 0x7c, 0x25, 0x87, 0x8c, 0xcf, 0xbd, 0x38, 0x35,
	0x2f, 0x4b, 0x18, 0xcd, 0xa0, 0xf5, 0xe8, 0xd7, 0xfe, 0xf5, 0xef, 0xb7, 0xef, 0x7f, 0xb8, 0x75,
	0x7e, 0x7e, 0xff, 0xc6, 0x7c, 0xa2, 0x40, 0xfe, 0x7e, 0x81, 0xba, 0x8d, 0x9e, 0xf1, 0x7e, 0x8d,
	0xf0, 0x6c, 0x6f, 0xf1, 0xd5, 0x2e, 0x8d, 0x78, 0x44, 0xe2, 0xe8, 0x0d, 0xb9, 0x5f, 0xde, 0x4b,
	0xb6, 0xf9, 0x1a, 0x14, 0xad, 0xf4, 0x73, 0xc7, 0x60, 0x2a, 0xad, 0x8f, 0x4b, 0xad, 0x97, 0x5b,
	0x0f, 0x09, 0xad, 0x59, 0xb8, 0xe7, 0x47, 0x35, 0x9c, 0x50, 0x7b, 0x80, 0x4f, 0x2e, 0xa6, 0xd1,
	0x3e, 0xdc, 0xdb, 0x05, 0x88, 0x33, 0xef, 0x39, 0xdb, 0x64, 0x15, 0xb0, 0x16, 0xf8, 0xfc, 0x54,
	0x1c, 0x25, 0xed, 0x3e, 0xef, 0xdb, 0x08, 0x9f, 0xdf, 0x8c, 0xc9, 0x61, 0x9b, 0x46, 0x23, 0x29,
	0x67, 0x3b, 0x8d, 0x86, 0x43, 0x48, 0xbd, 0x97, 0xad, 0x5b, 0x63, 0x60, 0x69, 0x31, 0x37, 0xa7,
	0x22, 0x57, 0xe4, 0xbc, 0x89, 0x4f, 0xd7, 0x1e, 0x79, 0x2f, 0x4c, 0x39, 0xd2, 0x7f, 0x39, 0xff,
	0xcf, 0x10, 0x3e, 0xb3, 0x1a, 0x65, 0xbc, 0x7c, 0x96, 0x79, 0xd6, 0xb1, 0xea, 0x78, 0x2d, 0xe1,
	0xd6, 0xb4, 0x34, 0xa5, 0xe1, 0xaa, 0xf4, 0x96, 0x4b, 0xad, 0x73, 0xc2, 0x5b, 0xe2, 0x28, 0xe3,
	0x3e, 0x29, 0x41, 0xc2, 0x55, 0x3e, 0x42, 0xf8, 0x42, 0x8d, 0xaa, 0x4c, 0x9f, 0x79, 0xaf, 0x4c,
	0x35, 0xa3, 0xa6, 0x69, 0xbd, 0x9f, 0x3f, 0x26, 0x5b, 0xc9, 0x7e, 0x52, 0xca, 0x7e, 0xac, 0x75,
	0xb9, 0x29, 0xdb, 0xe7, 0x0a, 0x2c, 0xe4, 0x33, 0xfc, 0xe0, 0x1a, 0xdb, 0x87, 0x3b, 0x40, 0x42,
	0x6f, 0xde, 0x36, 0xa5, 0x46, 0x6a, 0x8d, 0xd7, 0xdd, 0x09, 0xe5, 0x8e, 0xaa, 0x09, 0x57, 0xa3,
	0x01, 0x77, 0x9b, 0x50, 0x20, 0xa7, 0x9a, 0xb0, 0x20, 0x54, 0x5d, 0xb8, 0xc7, 0x59, 0xd2, 0x8e,
	0xe3, 0x35, 0xc6, 0x59, 0x9a, 0xd9, 0x5d, 0xb8, 0x06, 0x77, 0x76, 0xe1, 0x09, 0x56, 0x39, 0xff,
	0x1f, 0x11, 0x3e, 0xb7, 0x18, 0x65, 0x49, 0x4c, 0x0e, 0x97, 0x49, 0x00, 0xdd, 0x11, 0x19, 0xc2,
	0xd6, 0xca, 0x82, 0x77, 0xdb, 0x7a, 0x40, 0x34, 0x49, 0x5a, 0xcc, 0xcb, 0xc7, 0xe2, 0x2a, 0x49,
	0x9f, 0x96, 0xae, 0xf1, 0x68, 0x6b, 0x4e, 0xb8, 0x46, 0x58, 0x00, 0x7d, 0xc1, 0xf2, 0x23, 0x01,
	0xf5, 0xd3, 0x61, 0x5f, 0x78, 0xc6, 0x4f, 0x11, 0x3e, 0xb9, 0xb4, 0x0f, 0x94, 0xf7, 0x78, 0x0a,
	0x64, 0xe4, 0x3d, 0x6b, 0x9b, 0x53, 0x82, 0xb5, 0xc2, 0xcf, 0x3a, 0xa2, 0x95, 0xa6, 0x79, 0xa9,
	0xe9, 0xe9, 0xd6, 0x59, 0xa1, 0x09, 0xc4, 0x23, 0x3f, 0x93, 0xd3, 0xde, 0x46, 0xcf, 0x7c, 0xd9,
	0xf3, 0x1a, 0xff, 0x7d, 0x1d, 0x79, 0xef, 0x20, 0x7c, 0x59, 0x47, 0xc3, 0x76, 0x1e, 0x46, 0xac,
	0xd0, 0x29, 0x4e, 0x92, 0x3e, 0x09, 0xf6, 0xec, 0xf6, 0x35, 0x90, 0x9d, 0xed, 0x6b, 0xe4, 0xea,
	0x2d, 0x7f, 0x0a, 0x5d, 0x47, 0xde, 0x5b, 0x08, 0xcf, 0x2c, 0xa8, 0xcc, 0xa3, 0xc3, 0x28, 0x4f,
	0x59, 0x6c, 0x0f, 0xcb, 0x13, 0x04, 0xe7, 0xb0, 0xdc, 0xe0, 0xd5, 0xa4, 0xfc, 0x19, 0xe1, 0xf3,
	0x1d, 0x42, 0x03, 0x88, 0x85, 0x3f, 0x2c, 0xd1, 0x94, 0xc5, 0xf1, 0x08, 0x28, 0xb7, 0xc7, 0x14,
	0x13, 0x4b, 0x8b, 0x7a, 0xe5, 0x78, 0x64, 0x93, 0x13, 0x06, 0x12, 0x59, 0xf8, 0x20, 0x94, 0x58,
	0xe1, 0x84, 0x42, 0xba, 0x9a, 0xb0, 0x18, 0x04, 0xc2, 0x75, 0x32, 0x82, 0xcc, 0x2e, 0xdd, 0xc4,
	0x72, 0x96, 0x6e, 0x26, 0x9b, 0xa4, 0xa7, 0x05, 0x52, 0xc9, 0x86, 0xd0, 0xa7, 0x02, 0x2b, 0xa4,
	0xff, 0x1d, 0xe1, 0x87, 0x76, 0x92, 0x90, 0x70, 0xd0, 0xc3, 0x08, 0x53, 0x2c, 0x1c, 0x76, 0x17,
	0x3d, 0xeb, 0xd9, 0x6e, 0xe6, 0x69, 0xf9, 0x5f, 0x38, 0x2e, 0x5d, 0x2d, 0xe0, 0x69, 0xb9, 0x80,
	0x27, 0x5a, 0x57, 0xc5, 0x02, 0x72, 0x89, 0x1d, 0xeb, 0x97, 0x9b, 0xd0, 0x3f, 0xf4, 0xa3, 0x50,
	0x2c, 0xe2, 0xaf, 0x08, 0x5f, 0x58, 0x4a, 0x49, 0xd6, 0x5c, 0x83, 0xd5, 0x86, 0x46, 0x9a, 0x73,
	0x74, 0x3b, 0x82, 0xad, 0x56, 0xf0, 0x94, 0x5c, 0x41, 0xab, 0xf5, 0x88, 0x3c, 0x17, 0x04, 0xf4,
	0xa8, 0x05, 0xfc, 0x45, 0x2f, 0xa0, 0x1d, 0xc7, 0xd5, 0xe1, 0x32, 0xc7, 0x05, 0x4c, 0xd2, 0xa6,
	0x5b, 0x40, 0x93, 0xad, 0x16, 0xf0, 0x19, 0xb9, 0x80, 0xc7, 0x5b, 0x57, 0xc6, 0x0b, 0x20, 0x71,
	0x5c, 0x5f, 0x84, 0xf4, 0xa2, 0x5f, 0x20, 0x3c, 0xd3, 0x03, 0x2e, 0xd8, 0xdb, 0xac, 0x18, 0xcb,
	0x7e, 0x8c, 0x4c, 0x10, 0x9c, 0x8f, 0x91, 0x06, 0xcf, 0x98, 0x31, 0x03, 0x2f, 0x6c, 0xcc, 0x99,
	0xd2, 0x2b, 0x74, 0x7e, 0x17, 0x61, 0x5c, 0xb0, 0xc4, 0x08, 0xde, 0x0d, 0xab, 0x79, 0x4a, 0xac,
	0x56, 0xf7, 0xdc, 0x34, 0x14, 0x25, 0x6c, 0x4e, 0x0a, 0x3b, 0xdf, 0x9a, 0x91, 0x66, 0x94, 0xcf,
	0xa5, 0x36, 0x9d, 0x98, 0x2d, 0x51, 0xd2, 0x8f, 0x61, 0x8d, 0xa4, 0x7b, 0x90, 0x2e, 0x02, 0x87,
	0x40, 0xe6, 0xb0, 0xf6, 0x9d, 0x37, 0xd1, 0xdc, 0x77, 0xde, 0xcc, 0x36, 0x25, 0x66, 0x20, 0xa1,
	0xfe, 0x48, 0x62, 0xfd, 0x50, 0x83, 0x85, 0xfc, 0x3f, 0x20, 0x7c, 0xae, 0x18, 0x49, 0xac, 0x78,
	0x2c, 0xfe, 0xb6, 0xdb, 0xf4, 0x35, 0x92, 0x7b, 0x58, 0x33, 0x71, 0x95, 0xf0, 0x4f, 0x49, 0xe1,
	0x57, 0x5b, 0x0f, 0x57, 0x84, 0x4b, 0x3f, 0xa8, 0xc9, 0xae, 0x58, 0x9d, 0x89, 0xff, 0x9b, 0xde,
	0xea, 0x75, 0xda, 0xb4, 0x56, 0x9f, 0x64, 0x7f, 0x9c, 0xd5, 0x25, 0xb6, 0x2e, 0xff, 0x03, 0x84,
	0xcf, 0xaa, 0x91, 0xa2, 0x34, 0x65, 0xe9, 0x1a, 0x0b, 0xc1, 0x7b, 0xd1, 0x71, 0xee, 0x92, 0xa1,
	0x45, 0xbf, 0x34, 0x3d, 0xd1, 0xf4, 0xc6, 0x69, 0xbd, 0x12, 0xe6, 0x8f, 0x58, 0x08, 0x3a, 0x34,
	0x16, 0x7c, 0x99, 0xe1, 0x15, 0x49, 0x48, 0x44, 0x87, 0x9e, 0xe3, 0x2e, 0xd7, 0x59, 0xce, 0xa1,
	0xd1, 0x4c, 0x36, 0x85, 0x46, 0x25, 0xbb, 0x48, 0x2a, 0x33, 0x8d, 0x15, 0xd2, 0xff, 0x81, 0xf0,
	0xc5, 0x6e, 0x56, 0x1f, 0xa3, 0x18, 0x37, 0xf4, 0xac, 0xc1, 0xed, 0x08, 0xa2, 0x5e, 0xc0, 0x17,
	0x8f, 0xcd, 0x37, 0x45, 0xc7, 0x28, 0x9b, 0xd4, 0xef, 0x17, 0xcb, 0x92, 0xc1, 0xe5, 0x4f, 0x08,
	0x9f, 0x2b, 0xb2, 0x9c, 0xb6, 0xf4, 0xa0, 0x85, 0xc3, 0x6e, 0xb8, 0x4d, 0x86, 0xf6, 0x77, 0xd4,
	0x40, 0x72, 0x7e, 0x47, 0x8d, 0x5c, 0x93, 0x9b, 0xab, 0xac, 0x8a, 0x48, 0x64, 0x11, 0x11, 0x7d,
	0x4e, 0xe4, 0x06, 0x88, 0xb2, 0xba, 0x18, 0x47, 0x67, 0x8e, 0xf6, 0xb2, 0xba, 0x8e, 0x77, 0x2e,
	0xab, 0x27, 0x69, 0xa6, 0xb2, 0x5a, 0x29, 0xd5, 0x8d, 0x3a, 0xa1, 0xf0, 0x2d, 0x84, 0x1f, 0x5c,
	0x61, 0xdb, 0x6c, 0x93, 0x65, 0x60, 0xaf, 0x13, 0x35, 0xd2, 0xb9, 0x4e, 0x1c, 0x13, 0x94, 0x9e,
	0x87, 0xa5, 0x9e, 0x73, 0xad, 0x33, 0x42, 0xcf, 0x90, 0x89, 0xe0, 0x96, 0xb0, 0x4c, 0xbe, 0x68,
	0x3f, 0x41, 0xf8, 0xd4, 0x22, 0x0b, 0xf6, 0xee, 0x45, 0x7c, 0xb7, 0x93, 0xf7, 0xc1, 0xb3, 0xb7,
	0x76, 0x2a, 0x68, 0x2d, 0xe9, 0x85, 0xe9, 0x48, 0x4a, 0xd6, 0x23, 0x52, 0xd6, 0xc5, 0x96, 0x27,
	0x6b, 0x35, 0x16, 0xec, 0xf9, 0xaf, 0x47, 0x7c, 0xd7, 0x0f, 0xf2, 0xbe, 0x94, 0xf6, 0x3e, 0xc2,
	0x33, 0xb2, 0x8f, 0xb4, 0x31, 0x18, 0x74, 0x76, 0x49, 0x3a, 0x84, 0xd4, 0x9e, 0x1d, 0x4c, 0x10,
	0x9c, 0xb3, 0x83, 0x06, 0x4f, 0x69, 0x7c, 0x4c, 0x6a, 0x9c, 0x6b, 0x5d, 0x90, 0x1a, 0x05, 0xc8,
	0x67, 0x83, 0x81, 0x1f, 0x14, 0x30, 0x21, 0xf3, 0xe7, 0x08, 0x9f, 0x29, 0xd8, 0x54, 0xab, 0xbc,
	0xe9, 0x36, 0x1b, 0x9d, 0x10, 0x79, 0x6b, 0x5a, 0x9a, 0xa9, 0x3f, 0xa9, 0x34, 0xd2, 0xaa, 0xc4,
	0x6f, 0x21, 0x7c, 0x62, 0x39, 0xa2, 0x2a, 0x37, 0xb4, 0xfa, 0x4f, 0x09, 0xd5, 0xc2, 0x6e, 0x4c,
	0xc1, 0x30, 0xb9, 0xdc, 0x20, 0xa2, 0x95, 0xac, 0xef, 0x37, 0x08, 0xcf, 0xae, 0x32, 0xb6, 0xd7,
	0x4e, 0x59, 0x4e, 0xc3, 0x2e, 0xdd, 0x8c, 0x45, 0x52, 0x65, 0x0d, 0x27, 0x0d, 0x8a, 0x73, 0xb7,
	0xd4, 0xc0, 0x54, 0x2a, 0x9f, 0x90, 0x2a, 0x1f, 0x69, 0x5d, 0x92, 0x8d, 0x24, 0xc6, 0xf6, 0x7c,
	0x22, 0x71, 0x7e, 0x44, 0xfd, 0x24, 0x56, 0xb9, 0x96, 0xb0, 0xde, 0x16, 0x8b, 0xe3, 0x85, 0x98,
	0x05, 0x7b, 0x76, 0xeb, 0x95, 0x50, 0x67, 0xeb, 0x55, 0x18, 0x26, 0xeb, 0xc9, 0xc4, 0xaf, 0x2f,
	0x9e, 0xeb, 0x5c, 0x74, 0x73, 0x97, 0x71, 0x96, 0x75, 0xe9, 0x80, 0xd9, 0x73, 0xd1, 0x31, 0xd6,
	0x39, 0x17, 0xad, 0x52, 0x4c, 0xb9, 0x68, 0x22, 0x9f, 0xfb, 0x11, 0x1d, 0x30, 0xa1, 0xe8, 0x0d,
	0xfc, 0x80, 0x64, 0xd8, 0x9b, 0x28, 0x12, 0xe6, 0xdc, 0x44, 0x51, 0x68, 0xa5, 0xe0, 0xbc, 0x54,
	0x70, 0xa6, 0x75, 0xa2, 0x54, 0x20, 0xe6, 0xfe, 0x26, 0xc2, 0x27, 0xb6, 0x77, 0xf3, 0x51, 0x9f,
	0x92, 0x28, 0xb6, 0xef, 0x4d, 0x09, 0x75, 0xde, 0x9b, 0x0a, 0x43, 0x09, 0xb9, 0x24, 0x85, 0x78,
	0xad, 0xd3, 0x42, 0x08, 0xd7, 0x8f, 0x85, 0x98, 0xb7, 0x11, 0x3e, 0xb9, 0x08, 0x31, 0x70, 0x28,
	0xec, 0x61, 0xef, 0xac, 0x8f, 0xc1, 0xee, 0x9d, 0xf5, 0x2a, 0x47, 0x49, 0xba, 0x2c, 0x25, 0x5d,
	0x28, 0x1a, 0x4c, 0xa1, 0x04, 0xf8, 0xa5, 0x89, 0xde, 0xc4, 0xa7, 0xe5, 0xb9, 0xd1, 0xe3, 0x29,
	0x89, 0x86, 0xbb, 0xdc, 0xde, 0x22, 0xac, 0xc1, 0x9d, 0x5b, 0x84, 0x13, 0xac, 0xb2, 0x45, 0x78,
	0x80, 0x4f, 0x6e, 0xe7, 0x29, 0xd5, 0xef, 0xb9, 0xd5, 0x28, 0x15, 0xb0, 0xb3, 0x51, 0x6a, 0x9c,
	0x72, 0xe6, 0xaf, 0xe2, 0x53, 0x3d, 0xe0, 0x77, 0x80, 0x84, 0x6d, 0x3a, 0x8c, 0x1d, 0x42, 0x5b,
	0x15, 0xed, 0x1c, 0xda, 0xea, 0xa4, 0x5a, 0x67, 0x16, 0xf8, 0x6a, 0x34, 0xe0, 0x77, 0xc0, 0xcd,
	0xec, 0x35, 0xb8, 0x7b, 0x67, 0xb6, 0xce, 0x2a, 0xe7, 0xff, 0x06, 0xc2, 0x33, 0xc2, 0x2c, 0xdb,
	0xec, 0x75, 0x92, 0x86, 0x99, 0x2c, 0x5c, 0x6f, 0xb9, 0xd8, 0xb1, 0x42, 0x70, 0x8e, 0x9e, 0x0d,
	0x5e, 0x29, 0x23, 0xc7, 0x58, 0xa4, 0x23, 0x1b, 0xfd, 0xd7, 0x20, 0xe0, 0xf6, 0xd3, 0x6a, 0x8c,
	0x75, 0x3e, 0xad, 0xaa, 0x94, 0xea, 0xb4, 0xe2, 0x54, 0x75, 0x9d, 0x76, 0x8c, 0x75, 0x9e, 0xb6,
	0x4a, 0xa9, 0xfa, 0xfa, 0x26, 0x4b, 0xda, 0xf2, 0xc3, 0x57, 0xe4, 0xe0, 0xeb, 0x15, 0xb0, 0xb3,
	0xaf, 0xd7, 0x38, 0x55, 0x5f, 0xdf, 0x8c, 0x82, 0xbd, 0x3c, 0x51, 0x4b, 0xb6, 0x0f, 0x53, 0x41,
	0x3b, 0xfb, 0x7a, 0x9d, 0x54, 0x4e, 0xfe, 0x0e, 0xc2, 0x17, 0xe5, 0xcb, 0x57, 0x3c, 0xd9, 0xa0,
	0x2b, 0x32, 0x8a, 0xde, 0x81, 0x14, 0xec, 0x25, 0xcf, 0x11, 0x44, 0xe7, 0x92, 0xe7, 0x48, 0x7e,
	0xe5, 0x55, 0x9c, 0xe9, 0x01, 0x5f, 0x23, 0x19, 0x87, 0xf4, 0x2e, 0x8b, 0xf3, 0x91, 0xc3, 0x51,
	0x50, 0x45, 0x3b, 0x9b, 0xa7, 0x4e, 0x2a, 0xe7, 0xff, 0x2d, 0xc2, 0xde, 0x4e, 0x06, 0x69, 0x3b,
	0xe7, 0xbb, 0x40, 0x79, 0x14, 0x14, 0x5f, 0x1b, 0xad, 0x79, 0x4b, 0x93, 0xa3, 0x95, 0xdc, 0x3e,
	0x0e, 0x55, 0xe9, 0x69, 0xc9, 0x60, 0x71, 0xa5, 0x75, 0x51, 0x36, 0x48, 0x33, 0x48, 0x7d, 0x52,
	0x03, 0x8a, 0x98, 0xf1, 0x63, 0x84, 0x4f, 0x2d, 0x10, 0xce, 0x21, 0x3d, 0xec, 0x71, 0xc2, 0x1d,
	0xec, 0x55, 0x45, 0x3b, 0xdb, 0xab, 0x4e, 0x52, 0xfa, 0xae, 0x48, 0x7d, 0x0f, 0xb5, 0x66, 0x85,
	0xbe, 0x7e, 0x81, 0xf0, 0x33, 0x01, 0xd1, 0xca, 0xd4, 0xf7, 0x79, 0x47, 0x65, 0x55, 0xb4, 0xb3,
	0xb2, 0x3a, 0xc9, 0xa4, 0x4c, 0x7d, 0xfe, 0x1f, 0x2b, 0xfb, 0x3a, 0xc2, 0x9f, 0xec, 0x91, 0xc3,
	0x6d, 0x38, 0xe0, 0xde, 0x35, 0xeb, 0xa9, 0x5d, 0x00, 0xb5, 0x9e, 0x79, 0x67, 0xbc, 0x92, 0x72,
	0x51, 0x4a, 0x99, 0x6d, 0x9d, 0x92, 0x4d, 0x4b, 0x72, 0xe8, 0x73, 0x38, 0xe0, 0x3a, 0x07, 0xe9,
	0x30, 0x4a, 0x21, 0xe0, 0xb2, 0x9c, 0xb3, 0x1e, 0x41, 0x15, 0xb0, 0xf3, 0x11, 0x54, 0xe3, 0x98,
	0x72, 0x90, 0xa0, 0x00, 0x94, 0xa5, 0x9c, 0x28, 0xc9, 0x17, 0xa3, 0x2c, 0xa8, 0x08, 0xbb, 0xe9,
	0xf0, 0x95, 0x2f, 0x68, 0x6a, 0xbb, 0x35, 0x2d, 0xcd, 0x54, 0x92, 0x87, 0x25, 0xa6, 0xa6, 0x50,
	0x10, 0xb2, 0xf6, 0x3e, 0x89, 0x62, 0xd2, 0x8f, 0x1d, 0x14, 0xd6, 0xf1, 0xee, 0x4d, 0x83, 0x09,
	0x9a, 0xb1, 0x69, 0x20, 0x30, 0x3e, 0xd1, 0x20, 0x5d, 0x0e, 0x2f, 0xc7, 0x24, 0x93, 0x35, 0xf4,
	0xaa, 0x88, 0xf6, 0x99, 0x3d, 0xa0, 0x4f, 0x10, 0x9c, 0x03, 0x7a, 0x83, 0x67, 0x2a, 0x87, 0x07,
	0x02, 0x24, 0x2d, 0xe8, 0xc7, 0x12, 0xa6, 0x5b, 0xbb, 0xcb, 0x2c, 0x1d, 0x02, 0xdf, 0x4c, 0x61,
	0x00, 0x69, 0x0a, 0xa1, 0xdc, 0x6f, 0xeb, 0x91, 0x65, 0x20, 0x39, 0xb7, 0x8d, 0x8c, 0x5c, 0x53,
	0x6b, 0x77, 0x20, 0x81, 0x7e, 0xa2, 0x91, 0xe5, 0xfe, 0x7f, 0x80, 0xf0, 0xd9, 0xde, 0xa4, 0x66,
	0x97, 0x6f, 0x0a, 0x46, 0xc1, 0x2f, 0x4d, 0x4f, 0x3c, 0xea, 0x6b, 0x44, 0x53, 0xaa, 0xb0, 0x70,
	0x51, 0x05, 0x74, 0xf2, 0x8c, 0xb3, 0x51, 0x11, 0xfb, 0x32, 0x87, 0x6f, 0xee, 0x4d, 0x92, 0xfb,
	0x37, 0x77, 0x13, 0xd7, 0x64, 0x61, 0x55, 0x7e, 0x04, 0x12, 0xe9, 0xb3, 0x02, 0xaa, 0xfb, 0xa2,
	0x9d, 0x14, 0x08, 0x87, 0xe5, 0xe8, 0x40, 0xac, 0x7a, 0x3c, 0x94, 0x3d, 0x49, 0x38, 0x82, 0xe8,
	0x9c, 0x24, 0x1c, 0xc9, 0x37, 0xf5, 0x45, 0x03, 0x09, 0xf6, 0x07, 0x02, 0x5d, 0x5f, 0x88, 0x58,
	0xc7, 0xef, 0x10, 0xf6, 0x16, 0x61, 0x10, 0xd1, 0x9a, 0x35, 0xec, 0xd1, 0xbc, 0xc9, 0x71, 0x8e,
	0xe6, 0x26, 0xaa, 0xa9, 0x83, 0x11, 0x4a, 0x5c, 0x53, 0x72, 0x51, 0x8b, 0x54, 0xce, 0x0d, 0x97,
	0x5a, 0xa4, 0x79, 0x6a, 0xdc, 0x9c, 0x92, 0x55, 0x26, 0x40, 0xdf, 0x41, 0xf8, 0x84, 0xbc, 0x4c,
	0xb0, 0x0c, 0x10, 0xda, 0xab, 0xf4, 0x12, 0xea, 0x5c, 0xa5, 0x57, 0x18, 0xa6, 0x0e, 0x0a, 0x11,
	0x8f, 0xfd, 0x01, 0xc8, 0xc6, 0xf6, 0x75, 0xe4, 0x7d, 0x1f, 0x61, 0xdc, 0x21, 0x23, 0x48, 0x89,
	0x14, 0x74, 0xc3, 0xde, 0xe6, 0xd5, 0x58, 0xe7, 0xf2, 0xa0, 0x4a, 0x31, 0xf5, 0x50, 0x02, 0xf9,
	0xbc, 0xa2, 0x49, 0xb8, 0x55, 0x87, 0x24, 0x3c, 0x4f, 0xa1, 0x17, 0x89, 0x5a, 0x52, 0x36, 0xf2,
	0xed, 0x6e, 0xd5, 0xe4, 0x38, 0xbb, 0x95, 0x89, 0x6a, 0x72, 0xab, 0xa0, 0xc0, 0xf9, 0x99, 0x04,
	0x16, 0xdf, 0x0c, 0x84, 0x5b, 0xbd, 0x8b, 0xf0, 0xcc, 0x0a, 0xf0, 0x62, 0xa9, 0x1d, 0x46, 0x07,
	0xd1, 0xd0, 0x9e, 0x8e, 0x55, 0xd1, 0xce, 0xe9, 0x58, 0x9d, 0x64, 0x8a, 0x45, 0xe2, 0x54, 0x57,
	0x36, 0x0d, 0x24, 0x4c, 0x08, 0xfc, 0x21, 0xc2, 0x27, 0x7b, 0xc0, 0x97, 0x0e, 0xa1, 0xc3, 0x62,
	0x96, 0xda, 0x93, 0xa1, 0x0a, 0xd8, 0x39, 0x19, 0xaa, 0x71, 0x4c, 0x99, 0xa2, 0x38, 0xc5, 0xe1,
	0x10, 0xfc, 0x40, 0x40, 0x84, 0xac, 0x1f, 0x20, 0x8c, 0xd7, 0xc9, 0xfe, 0x1a, 0x49, 0xdc, 0xdc,
	0x6f, 0x8c, 0x75, 0x76, 0xbf, 0x2a, 0xc5, 0x94, 0xa0, 0xa9, 0xab, 0xc0, 0x15, 0xff, 0xfb, 0x10,
	0xe1, 0xd9, 0x9e, 0xde, 0xcc, 0x9e, 0xba, 0x1a, 0xec, 0xb9, 0x04, 0xb2, 0x3a, 0xc5, 0xfd, 0x0e,
	0x6b, 0x93, 0x69, 0xaa, 0x50, 0xb2, 0xf1, 0xc6, 0xea, 0x0b, 0xcb, 0xba, 0x29, 0xdb, 0x4e, 0x92,
	0x2e, 0xe5, 0x40, 0xb9, 0xc3, 0x91, 0xa2, 0xa1, 0xee, 0x47, 0xca, 0x98, 0x61, 0x3c, 0x52, 0x92,
	0x44, 0x82, 0x8b, 0x9b, 0x3c, 0xbf, 0x42, 0xd8, 0x5b, 0x01, 0xbe, 0x41, 0xfb, 0x8c, 0xa4, 0x61,
	0x44, 0x87, 0x45, 0x6d, 0x62, 0x4d, 0xcf, 0x26, 0x08, 0xce, 0xe9, 0x59, 0x83, 0x67, 0x7a, 0x6d,
	0xc5, 0x2b, 0xc1, 0x4a, 0xe0, 0xb8, 0x50, 0xf9, 0x10, 0xe1, 0x73, 0x3d, 0xa0, 0xe1, 0x78, 0x90,
	0x2e, 0x4d, 0x72, 0x3e, 0x8d, 0x5a, 0x49, 0x38, 0x86, 0x5a, 0xc5, 0x33, 0xe5, 0x0d, 0x19, 0xd0,
	0xb0, 0x2a, 0x37, 0x12, 0x50, 0x21, 0xf7, 0x9f, 0x08, 0xcf, 0xad, 0x00, 0x5f, 0x25, 0x1c, 0x32,
	0xde, 0xe6, 0xc2, 0xe4, 0xf2, 0x4e, 0x28, 0xa1, 0xd9, 0x00, 0x52, 0x7b, 0xea, 0x70, 0x04, 0xd1,
	0x39, 0x75, 0x38, 0x92, 0xaf, 0x56, 0xf1, 0xac, 0x5c, 0xc5, 0x93, 0xad, 0xc7, 0xb5, 0xcd, 0x63,
	0x49, 0xf0, 0x89, 0x66, 0xf8, 0x5c, 0x51, 0xb4, 0xdf, 0x6e, 0xe6, 0x71, 0xfc, 0xa5, 0x90, 0x05,
	0x0e, 0x9f, 0x62, 0x4a, 0xa8, 0xb3, 0xdf, 0x56, 0x18, 0x26, 0xbf, 0x4d, 0xf2, 0x38, 0xf6, 0x5f,
	0x13, 0xcf, 0x75, 0xd5, 0x53, 0xdc, 0xa7, 0x2a, 0xdf, 0xf8, 0x9b, 0x6e, 0xf7, 0xaf, 0x26, 0x5f,
	0xf7, 0x5b, 0xd3, 0xd2, 0x4c, 0x55, 0x8f, 0xba, 0xae, 0x55, 0x7d, 0xcf, 0x3f, 0x42, 0xf8, 0x42,
	0x41, 0x6d, 0x07, 0x01, 0xcb, 0x29, 0x2f, 0x85, 0xbe, 0xe2, 0x36, 0xe3, 0x04, 0xcd, 0xf9, 0xca,
	0xc5, 0x11, 0x6c, 0xd3, 0xb7, 0x68, 0x25, 0x9b, 0x14, 0xd8, 0x9a, 0xfc, 0xbf, 0x95, 0xf7, 0xe4,
	0x76, 0x32, 0x48, 0x97, 0x28, 0x8f, 0x78, 0x0c, 0x23, 0xa0, 0x3c, 0x73, 0xbd, 0x27, 0x37, 0xc9,
	0x9b, 0xf2, 0x9e, 0x5c, 0x93, 0x6e, 0xba, 0xa4, 0xa5, 0x56, 0x20, 0xbb, 0x41, 0x50, 0x41, 0xab,
	0xe3, 0x62, 0xb6, 0xc7, 0x49, 0xca, 0xf5, 0xc5, 0xbb, 0x61, 0x44, 0x1d, 0x3e, 0xd7, 0x75, 0x76,
	0x21, 0xd8, 0x53, 0x9b, 0xce, 0x09, 0xcf, 0xdd, 0x03, 0x83, 0x81, 0x69, 0x0c, 0x0c, 0x42, 0x93,
	0x5f, 0xde, 0xf0, 0x13, 0xaa, 0xb4, 0xdc, 0xc6, 0x08, 0xff, 0x07, 0x72, 0x03, 0x01, 0xd3, 0x72,
	0x33, 0x09, 0xd4, 0x75, 0xa7, 0x72, 0x35, 0x2a, 0x62, 0xb5, 0x58, 0x94, 0xbd, 0xee, 0x9c, 0x64,
	0x38, 0xd7, 0x9d, 0x4d, 0xa2, 0xa9, 0xee, 0xd4, 0x0e, 0x4d, 0x43, 0x3f, 0x2d, 0x70, 0xba, 0x01,
	0xb1, 0x93, 0xc4, 0x8c, 0x84, 0x8b, 0xd0, 0xcf, 0x87, 0xab, 0x6c, 0xe8, 0xd0, 0x80, 0x98, 0x20,
	0x38, 0xc7, 0x8c, 0x06, 0xcf, 0x94, 0xf4, 0xe5, 0x12, 0xe4, 0x87, 0x02, 0xe5, 0xc7, 0xac, 0x78,
	0xe5, 0xde, 0x47, 0xf8, 0xbc, 0xdc, 0x93, 0x4e, 0xcc, 0xf2, 0x50, 0xb5, 0xaa, 0x22, 0x46, 0x1d,
	0xd2, 0xfc, 0x92, 0xe5, 0x9e, 0xe6, 0x57, 0x28, 0xc6, 0xcb, 0xbf, 0x72, 0xd7, 0x03, 0x01, 0xf0,
	0x83, 0x52, 0x8a, 0x90, 0xf9, 0x23, 0x84, 0xcf, 0xac, 0x00, 0x5f, 0x06, 0x22, 0x72, 0xeb, 0xe5,
	0x98, 0x0c, 0xed, 0xe9, 0x69, 0x05, 0xec, 0x9c, 0x9e, 0xd6, 0x38, 0xa6, 0x54, 0x70, 0x50, 0x00,
	0xfc, 0x41, 0x5c, 0x5c, 0x9f, 0xf9, 0x65, 0x91, 0xcb, 0x54, 0x78, 0xab, 0x51, 0xe6, 0x90, 0x1d,
	0x4c, 0x10, 0xdc, 0x5b, 0x4d, 0x93, 0x3c, 0x63, 0xab, 0xa9, 0x22, 0xd2, 0x8f, 0xa3, 0x4c, 0x3a,
	0xe4, 0x7b, 0x08, 0xcf, 0xae, 0x00, 0x6f, 0xc7, 0x70, 0x40, 0xda, 0x39, 0xdf, 0x2d, 0x92, 0x2e,
	0x6b, 0x00, 0xab, 0xe3, 0x9d, 0x03, 0xd8, 0x24, 0xcd, 0x74, 0xf9, 0x42, 0xfe, 0x69, 0x9e, 0xec,
	0xa7, 0x8f, 0xd3, 0xad, 0xef, 0x21, 0x8c, 0x25, 0x77, 0x23, 0xe1, 0x5d, 0x07, 0x2f, 0x1c, 0x63,
	0x9d, 0xbd, 0xb0, 0x4a, 0x31, 0x6d, 0x71, 0x21, 0x8b, 0x25, 0xdc, 0x8f, 0xa4, 0xef, 0xfd, 0x1e,
	0xe1, 0x0b, 0xed, 0x2c, 0xcb, 0x47, 0xf0, 0x3f, 0xbf, 0xc4, 0x5f, 0x0b, 0xa4, 0x44, 0x6a, 0x2a,
	0xaf, 0x4a, 0x89, 0x37, 0x46, 0x80, 0x65, 0x81, 0xd2, 0xff, 0x84, 0xfc, 0xcb, 0xbb, 0xe7, 0xff,
	0x13, 0x00, 0x00, 0xff, 0xff, 0xdb, 0xee, 0xa9, 0x6c, 0x58, 0x39, 0x00, 0x00,
}
