// Autogenerated Go message buffer code.
// Source: clad/cloud/token.clad
// Full command line: victor-clad/tools/message-buffers/emitters/Go_emitter.py -C src -o generated/cladgo/src clad/cloud/token.clad

package cloud

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"

	"github.com/digital-dream-labs/vector-cloud/internal/clad"
)

// ENUM TokenError
type TokenError uint8

const (
	TokenError_NoError TokenError = iota
	TokenError_NullToken
	TokenError_InvalidToken
	TokenError_Connection
	TokenError_WrongAccount
)

// STRUCTURE AuthRequest
type AuthRequest struct {
	SessionToken string
	ClientName   string
	AppId        string
}

func (a *AuthRequest) Size() uint32 {
	var result uint32
	result += 1                           // SessionToken length (uint_8)
	result += uint32(len(a.SessionToken)) // uint_8 array
	result += 1                           // ClientName length (uint_8)
	result += uint32(len(a.ClientName))   // uint_8 array
	result += 1                           // AppId length (uint_8)
	result += uint32(len(a.AppId))        // uint_8 array
	return result
}

func (a *AuthRequest) Unpack(buf *bytes.Buffer) error {
	var SessionTokenLen uint8
	if err := binary.Read(buf, binary.LittleEndian, &SessionTokenLen); err != nil {
		return err
	}
	a.SessionToken = string(buf.Next(int(SessionTokenLen)))
	if len(a.SessionToken) != int(SessionTokenLen) {
		return errors.New("string byte mismatch")
	}
	var ClientNameLen uint8
	if err := binary.Read(buf, binary.LittleEndian, &ClientNameLen); err != nil {
		return err
	}
	a.ClientName = string(buf.Next(int(ClientNameLen)))
	if len(a.ClientName) != int(ClientNameLen) {
		return errors.New("string byte mismatch")
	}
	var AppIdLen uint8
	if err := binary.Read(buf, binary.LittleEndian, &AppIdLen); err != nil {
		return err
	}
	a.AppId = string(buf.Next(int(AppIdLen)))
	if len(a.AppId) != int(AppIdLen) {
		return errors.New("string byte mismatch")
	}
	return nil
}

func (a *AuthRequest) Pack(buf *bytes.Buffer) error {
	if len(a.SessionToken) > 255 {
		return errors.New("max_length overflow in field SessionToken")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint8(len(a.SessionToken))); err != nil {
		return err
	}
	if _, err := buf.WriteString(a.SessionToken); err != nil {
		return err
	}
	if len(a.ClientName) > 255 {
		return errors.New("max_length overflow in field ClientName")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint8(len(a.ClientName))); err != nil {
		return err
	}
	if _, err := buf.WriteString(a.ClientName); err != nil {
		return err
	}
	if len(a.AppId) > 255 {
		return errors.New("max_length overflow in field AppId")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint8(len(a.AppId))); err != nil {
		return err
	}
	if _, err := buf.WriteString(a.AppId); err != nil {
		return err
	}
	return nil
}

func (a *AuthRequest) String() string {
	return fmt.Sprint("SessionToken: {", a.SessionToken, "} ",
		"ClientName: {", a.ClientName, "} ",
		"AppId: {", a.AppId, "}")
}

// STRUCTURE AuthResponse
type AuthResponse struct {
	AppToken string
	JwtToken string
	Error    TokenError
}

func (a *AuthResponse) Size() uint32 {
	var result uint32
	result += 2                       // AppToken length (uint_16)
	result += uint32(len(a.AppToken)) // uint_8 array
	result += 2                       // JwtToken length (uint_16)
	result += uint32(len(a.JwtToken)) // uint_8 array
	result += 1                       // Error TokenError
	return result
}

func (a *AuthResponse) Unpack(buf *bytes.Buffer) error {
	var AppTokenLen uint16
	if err := binary.Read(buf, binary.LittleEndian, &AppTokenLen); err != nil {
		return err
	}
	a.AppToken = string(buf.Next(int(AppTokenLen)))
	if len(a.AppToken) != int(AppTokenLen) {
		return errors.New("string byte mismatch")
	}
	var JwtTokenLen uint16
	if err := binary.Read(buf, binary.LittleEndian, &JwtTokenLen); err != nil {
		return err
	}
	a.JwtToken = string(buf.Next(int(JwtTokenLen)))
	if len(a.JwtToken) != int(JwtTokenLen) {
		return errors.New("string byte mismatch")
	}
	if err := binary.Read(buf, binary.LittleEndian, &a.Error); err != nil {
		return err
	}
	return nil
}

func (a *AuthResponse) Pack(buf *bytes.Buffer) error {
	if len(a.AppToken) > 65535 {
		return errors.New("max_length overflow in field AppToken")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint16(len(a.AppToken))); err != nil {
		return err
	}
	if _, err := buf.WriteString(a.AppToken); err != nil {
		return err
	}
	if len(a.JwtToken) > 65535 {
		return errors.New("max_length overflow in field JwtToken")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint16(len(a.JwtToken))); err != nil {
		return err
	}
	if _, err := buf.WriteString(a.JwtToken); err != nil {
		return err
	}
	if err := binary.Write(buf, binary.LittleEndian, a.Error); err != nil {
		return err
	}
	return nil
}

func (a *AuthResponse) String() string {
	return fmt.Sprint("AppToken: {", a.AppToken, "} ",
		"JwtToken: {", a.JwtToken, "} ",
		"Error: {", a.Error, "}")
}

// STRUCTURE ReassociateRequest
type ReassociateRequest struct {
	SessionToken string
	ClientName   string
	AppId        string
}

func (r *ReassociateRequest) Size() uint32 {
	var result uint32
	result += 1                           // SessionToken length (uint_8)
	result += uint32(len(r.SessionToken)) // uint_8 array
	result += 1                           // ClientName length (uint_8)
	result += uint32(len(r.ClientName))   // uint_8 array
	result += 1                           // AppId length (uint_8)
	result += uint32(len(r.AppId))        // uint_8 array
	return result
}

func (r *ReassociateRequest) Unpack(buf *bytes.Buffer) error {
	var SessionTokenLen uint8
	if err := binary.Read(buf, binary.LittleEndian, &SessionTokenLen); err != nil {
		return err
	}
	r.SessionToken = string(buf.Next(int(SessionTokenLen)))
	if len(r.SessionToken) != int(SessionTokenLen) {
		return errors.New("string byte mismatch")
	}
	var ClientNameLen uint8
	if err := binary.Read(buf, binary.LittleEndian, &ClientNameLen); err != nil {
		return err
	}
	r.ClientName = string(buf.Next(int(ClientNameLen)))
	if len(r.ClientName) != int(ClientNameLen) {
		return errors.New("string byte mismatch")
	}
	var AppIdLen uint8
	if err := binary.Read(buf, binary.LittleEndian, &AppIdLen); err != nil {
		return err
	}
	r.AppId = string(buf.Next(int(AppIdLen)))
	if len(r.AppId) != int(AppIdLen) {
		return errors.New("string byte mismatch")
	}
	return nil
}

func (r *ReassociateRequest) Pack(buf *bytes.Buffer) error {
	if len(r.SessionToken) > 255 {
		return errors.New("max_length overflow in field SessionToken")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint8(len(r.SessionToken))); err != nil {
		return err
	}
	if _, err := buf.WriteString(r.SessionToken); err != nil {
		return err
	}
	if len(r.ClientName) > 255 {
		return errors.New("max_length overflow in field ClientName")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint8(len(r.ClientName))); err != nil {
		return err
	}
	if _, err := buf.WriteString(r.ClientName); err != nil {
		return err
	}
	if len(r.AppId) > 255 {
		return errors.New("max_length overflow in field AppId")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint8(len(r.AppId))); err != nil {
		return err
	}
	if _, err := buf.WriteString(r.AppId); err != nil {
		return err
	}
	return nil
}

func (r *ReassociateRequest) String() string {
	return fmt.Sprint("SessionToken: {", r.SessionToken, "} ",
		"ClientName: {", r.ClientName, "} ",
		"AppId: {", r.AppId, "}")
}

// STRUCTURE SecondaryAuthRequest
type SecondaryAuthRequest struct {
	SessionToken string
	ClientName   string
	AppId        string
}

func (s *SecondaryAuthRequest) Size() uint32 {
	var result uint32
	result += 1                           // SessionToken length (uint_8)
	result += uint32(len(s.SessionToken)) // uint_8 array
	result += 1                           // ClientName length (uint_8)
	result += uint32(len(s.ClientName))   // uint_8 array
	result += 1                           // AppId length (uint_8)
	result += uint32(len(s.AppId))        // uint_8 array
	return result
}

func (s *SecondaryAuthRequest) Unpack(buf *bytes.Buffer) error {
	var SessionTokenLen uint8
	if err := binary.Read(buf, binary.LittleEndian, &SessionTokenLen); err != nil {
		return err
	}
	s.SessionToken = string(buf.Next(int(SessionTokenLen)))
	if len(s.SessionToken) != int(SessionTokenLen) {
		return errors.New("string byte mismatch")
	}
	var ClientNameLen uint8
	if err := binary.Read(buf, binary.LittleEndian, &ClientNameLen); err != nil {
		return err
	}
	s.ClientName = string(buf.Next(int(ClientNameLen)))
	if len(s.ClientName) != int(ClientNameLen) {
		return errors.New("string byte mismatch")
	}
	var AppIdLen uint8
	if err := binary.Read(buf, binary.LittleEndian, &AppIdLen); err != nil {
		return err
	}
	s.AppId = string(buf.Next(int(AppIdLen)))
	if len(s.AppId) != int(AppIdLen) {
		return errors.New("string byte mismatch")
	}
	return nil
}

func (s *SecondaryAuthRequest) Pack(buf *bytes.Buffer) error {
	if len(s.SessionToken) > 255 {
		return errors.New("max_length overflow in field SessionToken")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint8(len(s.SessionToken))); err != nil {
		return err
	}
	if _, err := buf.WriteString(s.SessionToken); err != nil {
		return err
	}
	if len(s.ClientName) > 255 {
		return errors.New("max_length overflow in field ClientName")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint8(len(s.ClientName))); err != nil {
		return err
	}
	if _, err := buf.WriteString(s.ClientName); err != nil {
		return err
	}
	if len(s.AppId) > 255 {
		return errors.New("max_length overflow in field AppId")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint8(len(s.AppId))); err != nil {
		return err
	}
	if _, err := buf.WriteString(s.AppId); err != nil {
		return err
	}
	return nil
}

func (s *SecondaryAuthRequest) String() string {
	return fmt.Sprint("SessionToken: {", s.SessionToken, "} ",
		"ClientName: {", s.ClientName, "} ",
		"AppId: {", s.AppId, "}")
}

// STRUCTURE JwtRequest
type JwtRequest struct {
	ForceRefresh bool
}

func (j *JwtRequest) Size() uint32 {
	var result uint32
	result += 1 // ForceRefresh bool
	return result
}

func (j *JwtRequest) Unpack(buf *bytes.Buffer) error {
	if err := binary.Read(buf, binary.LittleEndian, &j.ForceRefresh); err != nil {
		return err
	}
	return nil
}

func (j *JwtRequest) Pack(buf *bytes.Buffer) error {
	if err := binary.Write(buf, binary.LittleEndian, j.ForceRefresh); err != nil {
		return err
	}
	return nil
}

func (j *JwtRequest) String() string {
	return fmt.Sprint("ForceRefresh: {", j.ForceRefresh, "}")
}

// STRUCTURE JwtResponse
type JwtResponse struct {
	JwtToken string
	Error    TokenError
}

func (j *JwtResponse) Size() uint32 {
	var result uint32
	result += 2                       // JwtToken length (uint_16)
	result += uint32(len(j.JwtToken)) // uint_8 array
	result += 1                       // Error TokenError
	return result
}

func (j *JwtResponse) Unpack(buf *bytes.Buffer) error {
	var JwtTokenLen uint16
	if err := binary.Read(buf, binary.LittleEndian, &JwtTokenLen); err != nil {
		return err
	}
	j.JwtToken = string(buf.Next(int(JwtTokenLen)))
	if len(j.JwtToken) != int(JwtTokenLen) {
		return errors.New("string byte mismatch")
	}
	if err := binary.Read(buf, binary.LittleEndian, &j.Error); err != nil {
		return err
	}
	return nil
}

func (j *JwtResponse) Pack(buf *bytes.Buffer) error {
	if len(j.JwtToken) > 65535 {
		return errors.New("max_length overflow in field JwtToken")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint16(len(j.JwtToken))); err != nil {
		return err
	}
	if _, err := buf.WriteString(j.JwtToken); err != nil {
		return err
	}
	if err := binary.Write(buf, binary.LittleEndian, j.Error); err != nil {
		return err
	}
	return nil
}

func (j *JwtResponse) String() string {
	return fmt.Sprint("JwtToken: {", j.JwtToken, "} ",
		"Error: {", j.Error, "}")
}

// UNION TokenRequest
type TokenRequestTag uint8

const (
	TokenRequestTag_Auth        TokenRequestTag = iota // 0
	TokenRequestTag_Secondary                          // 1
	TokenRequestTag_Reassociate                        // 2
	TokenRequestTag_Jwt                                // 3
	TokenRequestTag_INVALID     TokenRequestTag = 255
)

type TokenRequest struct {
	tag   *TokenRequestTag
	value clad.Struct
}

func (m *TokenRequest) Tag() TokenRequestTag {
	if m.tag == nil {
		return TokenRequestTag_INVALID
	}
	return *m.tag
}

func (m *TokenRequest) Size() uint32 {
	if m.tag == nil || *m.tag == TokenRequestTag_INVALID {
		return 1
	}
	return 1 + m.value.Size()
}

func (m *TokenRequest) Pack(buf *bytes.Buffer) error {
	tag := TokenRequestTag_INVALID
	if m.tag != nil {
		tag = *m.tag
	}
	if err := binary.Write(buf, binary.LittleEndian, tag); err != nil {
		return err
	}
	if tag == TokenRequestTag_INVALID {
		return nil
	}
	return m.value.Pack(buf)
}

func (m *TokenRequest) unpackStruct(tag TokenRequestTag, buf *bytes.Buffer) (clad.Struct, error) {
	switch tag {
	case TokenRequestTag_Auth:
		var ret AuthRequest
		if err := ret.Unpack(buf); err != nil {
			return nil, err
		}
		return &ret, nil
	case TokenRequestTag_Secondary:
		var ret SecondaryAuthRequest
		if err := ret.Unpack(buf); err != nil {
			return nil, err
		}
		return &ret, nil
	case TokenRequestTag_Reassociate:
		var ret ReassociateRequest
		if err := ret.Unpack(buf); err != nil {
			return nil, err
		}
		return &ret, nil
	case TokenRequestTag_Jwt:
		var ret JwtRequest
		if err := ret.Unpack(buf); err != nil {
			return nil, err
		}
		return &ret, nil
	default:
		return nil, errors.New("invalid tag to unpackStruct")
	}
}

func (m *TokenRequest) Unpack(buf *bytes.Buffer) error {
	tag := TokenRequestTag_INVALID
	if err := binary.Read(buf, binary.LittleEndian, &tag); err != nil {
		return err
	}
	m.tag = &tag
	if tag == TokenRequestTag_INVALID {
		m.value = nil
		return nil
	}
	val, err := m.unpackStruct(tag, buf)
	if err != nil {
		*m.tag = TokenRequestTag_INVALID
		return err
	}
	m.value = val
	return nil
}

func (t TokenRequestTag) String() string {
	switch t {
	case TokenRequestTag_Auth:
		return "Auth"
	case TokenRequestTag_Secondary:
		return "Secondary"
	case TokenRequestTag_Reassociate:
		return "Reassociate"
	case TokenRequestTag_Jwt:
		return "Jwt"
	default:
		return "INVALID"
	}
}

func (m *TokenRequest) String() string {
	if m.tag == nil {
		return "nil"
	}
	if *m.tag == TokenRequestTag_INVALID {
		return "INVALID"
	}
	return fmt.Sprintf("%s: {%s}", *m.tag, m.value)
}

func (m *TokenRequest) GetAuth() *AuthRequest {
	if m.tag == nil || *m.tag != TokenRequestTag_Auth {
		return nil
	}
	return m.value.(*AuthRequest)
}

func (m *TokenRequest) SetAuth(value *AuthRequest) {
	newTag := TokenRequestTag_Auth
	m.tag = &newTag
	m.value = value
}

func NewTokenRequestWithAuth(value *AuthRequest) *TokenRequest {
	var ret TokenRequest
	ret.SetAuth(value)
	return &ret
}

func (m *TokenRequest) GetSecondary() *SecondaryAuthRequest {
	if m.tag == nil || *m.tag != TokenRequestTag_Secondary {
		return nil
	}
	return m.value.(*SecondaryAuthRequest)
}

func (m *TokenRequest) SetSecondary(value *SecondaryAuthRequest) {
	newTag := TokenRequestTag_Secondary
	m.tag = &newTag
	m.value = value
}

func NewTokenRequestWithSecondary(value *SecondaryAuthRequest) *TokenRequest {
	var ret TokenRequest
	ret.SetSecondary(value)
	return &ret
}

func (m *TokenRequest) GetReassociate() *ReassociateRequest {
	if m.tag == nil || *m.tag != TokenRequestTag_Reassociate {
		return nil
	}
	return m.value.(*ReassociateRequest)
}

func (m *TokenRequest) SetReassociate(value *ReassociateRequest) {
	newTag := TokenRequestTag_Reassociate
	m.tag = &newTag
	m.value = value
}

func NewTokenRequestWithReassociate(value *ReassociateRequest) *TokenRequest {
	var ret TokenRequest
	ret.SetReassociate(value)
	return &ret
}

func (m *TokenRequest) GetJwt() *JwtRequest {
	if m.tag == nil || *m.tag != TokenRequestTag_Jwt {
		return nil
	}
	return m.value.(*JwtRequest)
}

func (m *TokenRequest) SetJwt(value *JwtRequest) {
	newTag := TokenRequestTag_Jwt
	m.tag = &newTag
	m.value = value
}

func NewTokenRequestWithJwt(value *JwtRequest) *TokenRequest {
	var ret TokenRequest
	ret.SetJwt(value)
	return &ret
}

// UNION TokenResponse
type TokenResponseTag uint8

const (
	TokenResponseTag_Auth    TokenResponseTag = iota // 0
	TokenResponseTag_Jwt                             // 1
	TokenResponseTag_INVALID TokenResponseTag = 255
)

type TokenResponse struct {
	tag   *TokenResponseTag
	value clad.Struct
}

func (m *TokenResponse) Tag() TokenResponseTag {
	if m.tag == nil {
		return TokenResponseTag_INVALID
	}
	return *m.tag
}

func (m *TokenResponse) Size() uint32 {
	if m.tag == nil || *m.tag == TokenResponseTag_INVALID {
		return 1
	}
	return 1 + m.value.Size()
}

func (m *TokenResponse) Pack(buf *bytes.Buffer) error {
	tag := TokenResponseTag_INVALID
	if m.tag != nil {
		tag = *m.tag
	}
	if err := binary.Write(buf, binary.LittleEndian, tag); err != nil {
		return err
	}
	if tag == TokenResponseTag_INVALID {
		return nil
	}
	return m.value.Pack(buf)
}

func (m *TokenResponse) unpackStruct(tag TokenResponseTag, buf *bytes.Buffer) (clad.Struct, error) {
	switch tag {
	case TokenResponseTag_Auth:
		var ret AuthResponse
		if err := ret.Unpack(buf); err != nil {
			return nil, err
		}
		return &ret, nil
	case TokenResponseTag_Jwt:
		var ret JwtResponse
		if err := ret.Unpack(buf); err != nil {
			return nil, err
		}
		return &ret, nil
	default:
		return nil, errors.New("invalid tag to unpackStruct")
	}
}

func (m *TokenResponse) Unpack(buf *bytes.Buffer) error {
	tag := TokenResponseTag_INVALID
	if err := binary.Read(buf, binary.LittleEndian, &tag); err != nil {
		return err
	}
	m.tag = &tag
	if tag == TokenResponseTag_INVALID {
		m.value = nil
		return nil
	}
	val, err := m.unpackStruct(tag, buf)
	if err != nil {
		*m.tag = TokenResponseTag_INVALID
		return err
	}
	m.value = val
	return nil
}

func (t TokenResponseTag) String() string {
	switch t {
	case TokenResponseTag_Auth:
		return "Auth"
	case TokenResponseTag_Jwt:
		return "Jwt"
	default:
		return "INVALID"
	}
}

func (m *TokenResponse) String() string {
	if m.tag == nil {
		return "nil"
	}
	if *m.tag == TokenResponseTag_INVALID {
		return "INVALID"
	}
	return fmt.Sprintf("%s: {%s}", *m.tag, m.value)
}

func (m *TokenResponse) GetAuth() *AuthResponse {
	if m.tag == nil || *m.tag != TokenResponseTag_Auth {
		return nil
	}
	return m.value.(*AuthResponse)
}

func (m *TokenResponse) SetAuth(value *AuthResponse) {
	newTag := TokenResponseTag_Auth
	m.tag = &newTag
	m.value = value
}

func NewTokenResponseWithAuth(value *AuthResponse) *TokenResponse {
	var ret TokenResponse
	ret.SetAuth(value)
	return &ret
}

func (m *TokenResponse) GetJwt() *JwtResponse {
	if m.tag == nil || *m.tag != TokenResponseTag_Jwt {
		return nil
	}
	return m.value.(*JwtResponse)
}

func (m *TokenResponse) SetJwt(value *JwtResponse) {
	newTag := TokenResponseTag_Jwt
	m.tag = &newTag
	m.value = value
}

func NewTokenResponseWithJwt(value *JwtResponse) *TokenResponse {
	var ret TokenResponse
	ret.SetJwt(value)
	return &ret
}
