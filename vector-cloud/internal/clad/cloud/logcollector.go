// Autogenerated Go message buffer code.
// Source: clad/cloud/logcollector.clad
// Full command line: victor-clad/tools/message-buffers/emitters/Go_emitter.py -C src -o generated/cladgo/src clad/cloud/logcollector.clad

package cloud

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"

	"github.com/digital-dream-labs/vector-cloud/internal/clad"
)

// ENUM LogCollectorError
type LogCollectorError uint8

const (
	LogCollectorError_ErrorConnecting LogCollectorError = iota
)

// STRUCTURE UploadResponse
type UploadResponse struct {
	LogUrl string
}

func (u *UploadResponse) Size() uint32 {
	var result uint32
	result += 2                     // LogUrl length (uint_16)
	result += uint32(len(u.LogUrl)) // uint_8 array
	return result
}

func (u *UploadResponse) Unpack(buf *bytes.Buffer) error {
	var LogUrlLen uint16
	if err := binary.Read(buf, binary.LittleEndian, &LogUrlLen); err != nil {
		return err
	}
	u.LogUrl = string(buf.Next(int(LogUrlLen)))
	if len(u.LogUrl) != int(LogUrlLen) {
		return errors.New("string byte mismatch")
	}
	return nil
}

func (u *UploadResponse) Pack(buf *bytes.Buffer) error {
	if len(u.LogUrl) > 65535 {
		return errors.New("max_length overflow in field LogUrl")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint16(len(u.LogUrl))); err != nil {
		return err
	}
	if _, err := buf.WriteString(u.LogUrl); err != nil {
		return err
	}
	return nil
}

func (u *UploadResponse) String() string {
	return fmt.Sprint("LogUrl: {", u.LogUrl, "}")
}

// STRUCTURE UploadRequest
type UploadRequest struct {
	LogFileName string
}

func (u *UploadRequest) Size() uint32 {
	var result uint32
	result += 2                          // LogFileName length (uint_16)
	result += uint32(len(u.LogFileName)) // uint_8 array
	return result
}

func (u *UploadRequest) Unpack(buf *bytes.Buffer) error {
	var LogFileNameLen uint16
	if err := binary.Read(buf, binary.LittleEndian, &LogFileNameLen); err != nil {
		return err
	}
	u.LogFileName = string(buf.Next(int(LogFileNameLen)))
	if len(u.LogFileName) != int(LogFileNameLen) {
		return errors.New("string byte mismatch")
	}
	return nil
}

func (u *UploadRequest) Pack(buf *bytes.Buffer) error {
	if len(u.LogFileName) > 65535 {
		return errors.New("max_length overflow in field LogFileName")
	}
	if err := binary.Write(buf, binary.LittleEndian, uint16(len(u.LogFileName))); err != nil {
		return err
	}
	if _, err := buf.WriteString(u.LogFileName); err != nil {
		return err
	}
	return nil
}

func (u *UploadRequest) String() string {
	return fmt.Sprint("LogFileName: {", u.LogFileName, "}")
}

// UNION LogCollectorRequest
type LogCollectorRequestTag uint8

const (
	LogCollectorRequestTag_Upload  LogCollectorRequestTag = iota // 0
	LogCollectorRequestTag_INVALID LogCollectorRequestTag = 255
)

type LogCollectorRequest struct {
	tag   *LogCollectorRequestTag
	value clad.Struct
}

func (m *LogCollectorRequest) Tag() LogCollectorRequestTag {
	if m.tag == nil {
		return LogCollectorRequestTag_INVALID
	}
	return *m.tag
}

func (m *LogCollectorRequest) Size() uint32 {
	if m.tag == nil || *m.tag == LogCollectorRequestTag_INVALID {
		return 1
	}
	return 1 + m.value.Size()
}

func (m *LogCollectorRequest) Pack(buf *bytes.Buffer) error {
	tag := LogCollectorRequestTag_INVALID
	if m.tag != nil {
		tag = *m.tag
	}
	if err := binary.Write(buf, binary.LittleEndian, tag); err != nil {
		return err
	}
	if tag == LogCollectorRequestTag_INVALID {
		return nil
	}
	return m.value.Pack(buf)
}

func (m *LogCollectorRequest) unpackStruct(tag LogCollectorRequestTag, buf *bytes.Buffer) (clad.Struct, error) {
	switch tag {
	case LogCollectorRequestTag_Upload:
		var ret UploadRequest
		if err := ret.Unpack(buf); err != nil {
			return nil, err
		}
		return &ret, nil
	default:
		return nil, errors.New("invalid tag to unpackStruct")
	}
}

func (m *LogCollectorRequest) Unpack(buf *bytes.Buffer) error {
	tag := LogCollectorRequestTag_INVALID
	if err := binary.Read(buf, binary.LittleEndian, &tag); err != nil {
		return err
	}
	m.tag = &tag
	if tag == LogCollectorRequestTag_INVALID {
		m.value = nil
		return nil
	}
	val, err := m.unpackStruct(tag, buf)
	if err != nil {
		*m.tag = LogCollectorRequestTag_INVALID
		return err
	}
	m.value = val
	return nil
}

func (t LogCollectorRequestTag) String() string {
	switch t {
	case LogCollectorRequestTag_Upload:
		return "Upload"
	default:
		return "INVALID"
	}
}

func (m *LogCollectorRequest) String() string {
	if m.tag == nil {
		return "nil"
	}
	if *m.tag == LogCollectorRequestTag_INVALID {
		return "INVALID"
	}
	return fmt.Sprintf("%s: {%s}", *m.tag, m.value)
}

func (m *LogCollectorRequest) GetUpload() *UploadRequest {
	if m.tag == nil || *m.tag != LogCollectorRequestTag_Upload {
		return nil
	}
	return m.value.(*UploadRequest)
}

func (m *LogCollectorRequest) SetUpload(value *UploadRequest) {
	newTag := LogCollectorRequestTag_Upload
	m.tag = &newTag
	m.value = value
}

func NewLogCollectorRequestWithUpload(value *UploadRequest) *LogCollectorRequest {
	var ret LogCollectorRequest
	ret.SetUpload(value)
	return &ret
}

// STRUCTURE LogCollectorErrorResponse
type LogCollectorErrorResponse struct {
	Err LogCollectorError
}

func (l *LogCollectorErrorResponse) Size() uint32 {
	var result uint32
	result += 1 // Err LogCollectorError
	return result
}

func (l *LogCollectorErrorResponse) Unpack(buf *bytes.Buffer) error {
	if err := binary.Read(buf, binary.LittleEndian, &l.Err); err != nil {
		return err
	}
	return nil
}

func (l *LogCollectorErrorResponse) Pack(buf *bytes.Buffer) error {
	if err := binary.Write(buf, binary.LittleEndian, l.Err); err != nil {
		return err
	}
	return nil
}

func (l *LogCollectorErrorResponse) String() string {
	return fmt.Sprint("Err: {", l.Err, "}")
}

// UNION LogCollectorResponse
type LogCollectorResponseTag uint8

const (
	LogCollectorResponseTag_Upload  LogCollectorResponseTag = iota // 0
	LogCollectorResponseTag_Err                                    // 1
	LogCollectorResponseTag_INVALID LogCollectorResponseTag = 255
)

type LogCollectorResponse struct {
	tag   *LogCollectorResponseTag
	value clad.Struct
}

func (m *LogCollectorResponse) Tag() LogCollectorResponseTag {
	if m.tag == nil {
		return LogCollectorResponseTag_INVALID
	}
	return *m.tag
}

func (m *LogCollectorResponse) Size() uint32 {
	if m.tag == nil || *m.tag == LogCollectorResponseTag_INVALID {
		return 1
	}
	return 1 + m.value.Size()
}

func (m *LogCollectorResponse) Pack(buf *bytes.Buffer) error {
	tag := LogCollectorResponseTag_INVALID
	if m.tag != nil {
		tag = *m.tag
	}
	if err := binary.Write(buf, binary.LittleEndian, tag); err != nil {
		return err
	}
	if tag == LogCollectorResponseTag_INVALID {
		return nil
	}
	return m.value.Pack(buf)
}

func (m *LogCollectorResponse) unpackStruct(tag LogCollectorResponseTag, buf *bytes.Buffer) (clad.Struct, error) {
	switch tag {
	case LogCollectorResponseTag_Upload:
		var ret UploadResponse
		if err := ret.Unpack(buf); err != nil {
			return nil, err
		}
		return &ret, nil
	case LogCollectorResponseTag_Err:
		var ret LogCollectorErrorResponse
		if err := ret.Unpack(buf); err != nil {
			return nil, err
		}
		return &ret, nil
	default:
		return nil, errors.New("invalid tag to unpackStruct")
	}
}

func (m *LogCollectorResponse) Unpack(buf *bytes.Buffer) error {
	tag := LogCollectorResponseTag_INVALID
	if err := binary.Read(buf, binary.LittleEndian, &tag); err != nil {
		return err
	}
	m.tag = &tag
	if tag == LogCollectorResponseTag_INVALID {
		m.value = nil
		return nil
	}
	val, err := m.unpackStruct(tag, buf)
	if err != nil {
		*m.tag = LogCollectorResponseTag_INVALID
		return err
	}
	m.value = val
	return nil
}

func (t LogCollectorResponseTag) String() string {
	switch t {
	case LogCollectorResponseTag_Upload:
		return "Upload"
	case LogCollectorResponseTag_Err:
		return "Err"
	default:
		return "INVALID"
	}
}

func (m *LogCollectorResponse) String() string {
	if m.tag == nil {
		return "nil"
	}
	if *m.tag == LogCollectorResponseTag_INVALID {
		return "INVALID"
	}
	return fmt.Sprintf("%s: {%s}", *m.tag, m.value)
}

func (m *LogCollectorResponse) GetUpload() *UploadResponse {
	if m.tag == nil || *m.tag != LogCollectorResponseTag_Upload {
		return nil
	}
	return m.value.(*UploadResponse)
}

func (m *LogCollectorResponse) SetUpload(value *UploadResponse) {
	newTag := LogCollectorResponseTag_Upload
	m.tag = &newTag
	m.value = value
}

func NewLogCollectorResponseWithUpload(value *UploadResponse) *LogCollectorResponse {
	var ret LogCollectorResponse
	ret.SetUpload(value)
	return &ret
}

func (m *LogCollectorResponse) GetErr() *LogCollectorErrorResponse {
	if m.tag == nil || *m.tag != LogCollectorResponseTag_Err {
		return nil
	}
	return m.value.(*LogCollectorErrorResponse)
}

func (m *LogCollectorResponse) SetErr(value *LogCollectorErrorResponse) {
	newTag := LogCollectorResponseTag_Err
	m.tag = &newTag
	m.value = value
}

func NewLogCollectorResponseWithErr(value *LogCollectorErrorResponse) *LogCollectorResponse {
	var ret LogCollectorResponse
	ret.SetErr(value)
	return &ret
}
